[{"categories":["documentation"],"content":"了解如何在 LoveIt 主题中快速, 直观地创建和组织内容.","date":"2020-03-05","objectID":"/markdown2/","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/markdown2/"},{"categories":["documentation"],"content":"了解如何在 LoveIt 主题中快速, 直观地创建和组织内容. ","date":"2020-03-05","objectID":"/markdown2/:0:0","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/markdown2/"},{"categories":["documentation"],"content":"1 内容组织 以下是一些方便你清晰管理和生成文章的目录结构建议: 保持博客文章存放在 content/posts 目录, 例如: content/posts/我的第一篇文章.md 保持简单的静态页面存放在 content 目录, 例如: content/about.md 本地资源组织 本地资源引用\r有三种方法来引用图片和音乐等本地资源: 使用页面包中的页面资源. 你可以使用适用于 Resources.GetMatch 的值或者直接使用相对于当前页面目录的文件路径来引用页面资源. 将本地资源放在 assets 目录中, 默认路径是 /assets. 引用资源的文件路径是相对于 assets 目录的. 将本地资源放在 static 目录中, 默认路径是 /static. 引用资源的文件路径是相对于 static 目录的. 引用的优先级符合以上的顺序. 在这个主题中的很多地方可以使用上面的本地资源引用, 例如 链接, 图片, image shortcode, music shortcode 和前置参数中的部分参数. 页面资源或者 assets 目录中的图片处理会在未来的版本中得到支持. 非常酷的功能! ","date":"2020-03-05","objectID":"/markdown2/:1:0","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/markdown2/"},{"categories":["documentation"],"content":"2 前置参数 Hugo 允许你在文章内容前面添加 yaml, toml 或者 json 格式的前置参数. 注意\r不是所有的以下前置参数都必须在你的每篇文章中设置. 只有在文章的参数和你的 网站设置 中的 page 部分不一致时才有必要这么做.\r这是一个前置参数例子: --- title: \"我的第一篇文章\" subtitle: \"\" date: 2020-03-04T15:58:26+08:00 lastmod: 2020-03-04T15:58:26+08:00 draft: true author: \"\" authorLink: \"\" description: \"\" license: \"\" images: [] tags: [] categories: [] featuredImage: \"\" featuredImagePreview: \"\" hiddenFromHomePage: false hiddenFromSearch: false twemoji: false lightgallery: true ruby: true fraction: true fontawesome: true linkToMarkdown: true rssFullText: false toc: enable: true auto: true code: copy: true maxShownLines: 50 math: enable: false # ... mapbox: # ... share: enable: true # ... comment: enable: true # ... library: css: # someCSS = \"some.css\" # 位于 \"assets/\" # 或者 # someCSS = \"https://cdn.example.com/some.css\" js: # someJS = \"some.js\" # 位于 \"assets/\" # 或者 # someJS = \"https://cdn.example.com/some.js\" seo: images: [] # ... --- title: 文章标题. subtitle: 文章副标题. date: 这篇文章创建的日期时间. 它通常是从文章的前置参数中的 date 字段获取的, 但是也可以在 网站配置 中设置. lastmod: 上次修改内容的日期时间. draft: 如果设为 true, 除非 hugo 命令使用了 --buildDrafts/-D 参数, 这篇文章不会被渲染. author: 文章作者. authorLink: 文章作者的链接. description: 文章内容的描述. license: 这篇文章特殊的许可. images: 页面图片, 用于 Open Graph 和 Twitter Cards. tags: 文章的标签. categories: 文章所属的类别. featuredImage: 文章的特色图片. featuredImagePreview: 用在主页预览的文章特色图片. hiddenFromHomePage: 如果设为 true, 这篇文章将不会显示在主页上. hiddenFromSearch: 如果设为 true, 这篇文章将不会显示在搜索结果中. twemoji: 如果设为 true, 这篇文章会使用 twemoji. lightgallery: 如果设为 true, 文章中的图片将可以按照画廊形式呈现. ruby: 如果设为 true, 这篇文章会使用 上标注释扩展语法. fraction: 如果设为 true, 这篇文章会使用 分数扩展语法. fontawesome: 如果设为 true, 这篇文章会使用 Font Awesome 扩展语法. linkToMarkdown: 如果设为 true, 内容的页脚将显示指向原始 Markdown 文件的链接. rssFullText: 如果设为 true, 在 RSS 中将会显示全文内容. toc: 和 网站配置 中的 params.page.toc 部分相同. code: 和 网站配置 中的 params.page.code 部分相同. math: 和 网站配置 中的 params.page.math 部分相同. mapbox: 和 网站配置 中的 params.page.mapbox 部分相同. share: 和 网站配置 中的 params.page.share 部分相同. comment: 和 网站配置 中的 params.page.comment 部分相同. library: 和 网站配置 中的 params.page.library 部分相同. seo: 和 网站配置 中的 params.page.seo 部分相同. 技巧\rfeaturedImage 和 featuredImagePreview 支持本地资源引用的完整用法. 如果带有在前置参数中设置了 name: featured-image 或 name: featured-image-preview 属性的页面资源, 没有必要在设置 featuredImage 或 featuredImagePreview: resources: - name: featured-image src: featured-image.jpg - name: featured-image-preview src: featured-image-preview.jpg ","date":"2020-03-05","objectID":"/markdown2/:2:0","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/markdown2/"},{"categories":["documentation"],"content":"3 内容摘要 LoveIt 主题使用内容摘要在主页中显示大致文章信息。Hugo 支持生成文章的摘要. 文章摘要预览\r","date":"2020-03-05","objectID":"/markdown2/:3:0","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/markdown2/"},{"categories":["documentation"],"content":"自动摘要拆分 默认情况下, Hugo 自动将内容的前 70 个单词作为摘要. 你可以通过在 网站配置 中设置 summaryLength 来自定义摘要长度. 如果您要使用 CJK中文/日语/韩语 语言创建内容, 并且想使用 Hugo 的自动摘要拆分功能，请在 网站配置 中将 hasCJKLanguage 设置为 true. ","date":"2020-03-05","objectID":"/markdown2/:3:1","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/markdown2/"},{"categories":["documentation"],"content":"手动摘要拆分 另外, 你也可以添加 \u003c!--more--\u003e 摘要分割符来拆分文章生成摘要. 摘要分隔符之前的内容将用作该文章的摘要. 注意\r请小心输入\u003c!--more--\u003e ; 即全部为小写且没有空格.\r","date":"2020-03-05","objectID":"/markdown2/:3:2","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/markdown2/"},{"categories":["documentation"],"content":"前置参数摘要 你可能希望摘要不是文章开头的文字. 在这种情况下, 你可以在文章前置参数的 summary 变量中设置单独的摘要. ","date":"2020-03-05","objectID":"/markdown2/:3:3","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/markdown2/"},{"categories":["documentation"],"content":"使用文章描述作为摘要 你可能希望将文章前置参数中的 description 变量的内容作为摘要. 你仍然需要在文章开头添加 \u003c!--more--\u003e 摘要分割符. 将摘要分隔符之前的内容保留为空. 然后 LoveIt 主题会将你的文章描述作为摘要. ","date":"2020-03-05","objectID":"/markdown2/:3:4","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/markdown2/"},{"categories":["documentation"],"content":"摘要选择的优先级顺序 由于可以通过多种方式指定摘要, 因此了解顺序很有用. 如下: 如果文章中有 \u003c!--more--\u003e 摘要分隔符, 但分隔符之前没有内容, 则使用描述作为摘要. 如果文章中有 \u003c!--more--\u003e 摘要分隔符, 则将按照手动摘要拆分的方法获得摘要. 如果文章前置参数中有摘要变量, 那么将以该值作为摘要. 按照自动摘要拆分方法. 注意\r不建议在摘要内容中包含富文本块元素, 这会导致渲染错误. 例如代码块, 图片, 表格等.\r","date":"2020-03-05","objectID":"/markdown2/:3:5","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/markdown2/"},{"categories":["documentation"],"content":"4 Markdown 基本语法 这部分内容在 Markdown 基本语法页面 中介绍. ","date":"2020-03-05","objectID":"/markdown2/:4:0","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/markdown2/"},{"categories":["documentation"],"content":"5 Markdown 扩展语法 LoveIt 主题提供了一些扩展的语法便于你撰写文章. ","date":"2020-03-05","objectID":"/markdown2/:5:0","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/markdown2/"},{"categories":["documentation"],"content":"Emoji 支持 这部分内容在 Emoji 支持页面 中介绍. ","date":"2020-03-05","objectID":"/markdown2/:5:1","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/markdown2/"},{"categories":["documentation"],"content":"数学公式 LoveIt 基于 $\\KaTeX$ 提供数学公式的支持. 在你的 网站配置 中的 [params.math] 下面设置属性 enable = true, 并在文章的前置参数中设置属性 math: true来启用数学公式的自动渲染. $\\KaTeX$ 根据 特定的分隔符 来自动渲染公式. 技巧\r有一份 $\\KaTeX$ 中支持的 $\\TeX$ 函数 清单.\r注意\r由于 Hugo 在渲染 Markdown 文档时会根据 _/*/\u003e\u003e 之类的语法生成 HTML 文档, 并且有些转义字符形式的文本内容 (如 \\(/\\)/\\[/\\]/\\\\) 会自动进行转义处理, 因此需要对这些地方进行额外的转义字符表达来实现自动渲染: _ -\u003e \\_ * -\u003e \\* \u003e\u003e -\u003e \\\u003e\u003e \\( -\u003e \\\\( \\) -\u003e \\\\) \\[ -\u003e \\\\[ \\] -\u003e \\\\] \\\\ -\u003e \\\\\\\\ LoveIt 主题支持 raw shortcode 以避免这些转义字符, 它可以帮助您编写原始数学公式内容. 一个 raw 示例: 行内公式: 公式块: 呈现的输出效果如下: 行内公式: 公式块: 行内公式 默认的行内公式分割符有: $ ... $ \\( ... \\) (转义的: \\\\( ... \\\\)) 例如: $c = \\pm\\sqrt{a^2 + b^2}$ 和 \\\\(f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi\\\\) 呈现的输出效果如下: $c = \\pm\\sqrt{a^2 + b^2}$ 和 \\(f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi\\) 公式块 默认的公式块分割符有: $$ ... $$ \\[ ... \\] (转义的: \\\\[ ... \\\\]) \\begin{equation} ... \\end{equation} (不编号的: \\begin{equation*} ... \\end{equation*}) \\begin{align} ... \\end{align} (不编号的: \\begin{align*} ... \\end{align*}) \\begin{alignat} ... \\end{alignat} (不编号的: \\begin{alignat*} ... \\end{alignat*}) \\begin{gather} ... \\end{gather} (不编号的: \\begin{gather*} ... \\end{gather*}) \\begin{CD} ... \\end{CD} 例如: $$ c = \\pm\\sqrt{a^2 + b^2} $$ \\\\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\\\] \\begin{equation*} \\rho \\frac{\\mathrm{D} \\mathbf{v}}{\\mathrm{D} t}=\\nabla \\cdot \\mathbb{P}+\\rho \\mathbf{f} \\end{equation*} \\begin{equation} \\mathbf{E}=\\sum_{i} \\mathbf{E}\\_{i}=\\mathbf{E}\\_{1}+\\mathbf{E}\\_{2}+\\mathbf{E}_{3}+\\cdots \\end{equation} \\begin{align} a\u0026=b+c \\\\\\\\ d+e\u0026=f \\end{align} \\begin{alignat}{2} 10\u0026x+\u00263\u0026y = 2 \\\\\\\\ 3\u0026x+\u002613\u0026y = 4 \\end{alignat} \\begin{gather} a=b \\\\\\\\ e=b+c \\end{gather} \\begin{CD} A @\u003ea\\\u003e\u003e B \\\\\\\\ @VbVV @AAcA \\\\\\\\ C @= D \\end{CD} 呈现的输出效果如下: $$ c = \\pm\\sqrt{a^2 + b^2} $$ \\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\] \\begin{equation*} \\rho \\frac{\\mathrm{D} \\mathbf{v}}{\\mathrm{D} t}=\\nabla \\cdot \\mathbb{P}+\\rho \\mathbf{f} \\end{equation*} \\begin{equation} \\mathbf{E}=\\sum_{i} \\mathbf{E}_{i}=\\mathbf{E}_{1}+\\mathbf{E}_{2}+\\mathbf{E}_{3}+\\cdots \\end{equation} \\begin{align} a\u0026=b+c \\\\ d+e\u0026=f \\end{align} \\begin{alignat}{2} 10\u0026x+\u00263\u0026y = 2 \\\\ 3\u0026x+\u002613\u0026y = 4 \\end{alignat} \\begin{gather} a=b \\\\ e=b+c \\end{gather} \\begin{CD} A @\u003ea\u003e\u003e B \\\\ @VbVV @AAcA \\\\ C @= D \\end{CD} 技巧\r你可以在 网站配置 中自定义行内公式和公式块的分割符.\rCopy-tex Copy-tex 是一个 $\\KaTeX$ 的插件. 通过这个扩展, 在选择并复制 $\\KaTeX$ 渲染的公式时, 会将其 $\\LaTeX$ 源代码复制到剪贴板. 在你的 网站配置 中的 [params.math] 下面设置属性 copyTex = true 来启用 Copy-tex. 选择并复制上一节中渲染的公式, 可以发现复制的内容为 $\\LaTeX$ 源代码. mhchem mhchem 是一个 $\\KaTeX$ 的插件. 通过这个扩展, 你可以在文章中轻松编写漂亮的化学方程式. 在你的 网站配置 中的 [params.math] 下面设置属性 mhchem = true 来启用 mhchem. $$ \\ce{CO2 + C -\u003e 2 CO} $$ $$ \\ce{Hg^2+ -\u003e[I-] HgI2 -\u003e[I-] [Hg^{II}I4]^2-} $$ 呈现的输出效果如下: $$ \\ce{CO2 + C -\u003e 2 CO} $$ $$ \\ce{Hg^2+ -\u003e[I-] HgI2 -\u003e[I-] [Hg^{II}I4]^2-} $$ ","date":"2020-03-05","objectID":"/markdown2/:5:2","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/markdown2/"},{"categories":["documentation"],"content":"字符注音或者注释 LoveIt 主题支持一种 字符注音或者注释 Markdown 扩展语法: [Hugo]^(一个开源的静态网站生成工具) 呈现的输出效果如下: Hugo一个开源的静态网站生成工具 ","date":"2020-03-05","objectID":"/markdown2/:5:3","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/markdown2/"},{"categories":["documentation"],"content":"分数 LoveIt 主题支持一种 分数 Markdown 扩展语法: [浅色]/[深色] [99]/[100] 呈现的输出效果如下: 浅色/深色 90/100 ","date":"2020-03-05","objectID":"/markdown2/:5:4","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/markdown2/"},{"categories":["documentation"],"content":"Font Awesome LoveIt 主题使用 Font Awesome 作为图标库. 你同样可以在文章中轻松使用这些图标. 从 Font Awesome 网站 上获取所需的图标 class. 呈现的输出效果如下: 去露营啦!  很快就回来. 真开心! ","date":"2020-03-05","objectID":"/markdown2/:5:5","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/markdown2/"},{"categories":["Markdown"],"content":"这篇文章展示了基本的 Markdown 语法和格式.","date":"2019-12-01","objectID":"/markdown/","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/markdown/"},{"categories":["Markdown"],"content":"这篇文章提供了可以在 Hugo 的文章中使用的基本 Markdown 语法示例. 注意\r这篇文章借鉴了一篇很棒的来自 Grav 的文章. 如果你想了解 Loveit 主题的扩展 Markdown 语法, 请阅读扩展 Markdown 语法页面. 事实上, 编写 Web 内容很麻烦. WYSIWYG所见即所得 编辑器帮助减轻了这一任务. 但通常会导致代码太糟, 或更糟糕的是, 网页也会很丑. 没有通常伴随的所有复杂和丑陋的问题, Markdown 是一种更好的生成 HTML 内容的方式. 一些主要好处是: Markdown 简单易学, 几乎没有多余的字符, 因此编写内容也更快. 用 Markdown 书写时出错的机会更少. 可以产生有效的 XHTML 输出. 将内容和视觉显示保持分开, 这样就不会打乱网站的外观. 可以在你喜欢的任何文本编辑器或 Markdown 应用程序中编写内容. Markdown 使用起来很有趣! John Gruber, Markdown 的作者如是说: Markdown 格式的首要设计目标是更具可读性. 最初的想法是 Markdown 格式的文档应当以纯文本形式发布, 而不会看起来像被标签或格式说明所标记. 虽然 Markdown 的语法受到几种现有的文本到 HTML 转换工具的影响, 但 Markdown 语法的最大灵感来源是纯文本电子邮件的格式. – John Gruber 话不多说, 我们来回顾一下 Markdown 的主要语法以及生成的 HTML 样式! 技巧\r 将此页保存为书签，以备将来参考!\r","date":"2019-12-01","objectID":"/markdown/:0:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/markdown/"},{"categories":["Markdown"],"content":"1 标题 从 h2 到 h6 的标题在每个级别上都加上一个 ＃: ## h2 标题 ### h3 标题 #### h4 标题 ##### h5 标题 ###### h6 标题 输出的 HTML 看起来像这样: \u003ch2\u003eh2 标题\u003c/h2\u003e \u003ch3\u003eh3 标题\u003c/h3\u003e \u003ch4\u003eh4 标题\u003c/h4\u003e \u003ch5\u003eh5 标题\u003c/h5\u003e \u003ch6\u003eh6 标题\u003c/h6\u003e 标题 ID\r要添加自定义标题 ID, 请在与标题相同的行中将自定义 ID 放在花括号中: ### 一个很棒的标题 {#custom-id} 输出的 HTML 看起来像这样: \u003ch3 id=\"custom-id\"\u003e一个很棒的标题\u003c/h3\u003e ","date":"2019-12-01","objectID":"/markdown/:1:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/markdown/"},{"categories":["Markdown"],"content":"2 注释 注释是和 HTML 兼容的： \u003c!-- 这是一段注释 --\u003e 不能看到以下的注释: ","date":"2019-12-01","objectID":"/markdown/:2:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/markdown/"},{"categories":["Markdown"],"content":"3 水平线 HTML 中的 \u003chr\u003e 标签是用来在段落元素之间创建一个 “专题间隔” 的. 使用 Markdown, 你可以用以下方式创建一个 \u003chr\u003e 标签: ___: 三个连续的下划线 ---: 三个连续的破折号 ***: 三个连续的星号 呈现的输出效果如下: ","date":"2019-12-01","objectID":"/markdown/:3:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/markdown/"},{"categories":["Markdown"],"content":"4 段落 按照纯文本的方式书写段落, 纯文本在呈现的 HTML 中将用 \u003cp\u003e/\u003c/p\u003e 标签包裹. 如下段落: Lorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad. 输出的 HTML 看起来像这样: \u003cp\u003eLorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad.\u003c/p\u003e 可以使用一个空白行进行换行. ","date":"2019-12-01","objectID":"/markdown/:4:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/markdown/"},{"categories":["Markdown"],"content":"5 内联 HTML 元素 如果你需要某个 HTML 标签 (带有一个类), 则可以简单地像这样使用: Markdown 格式的段落. \u003cdiv class=\"class\"\u003e 这是 \u003cb\u003eHTML\u003c/b\u003e \u003c/div\u003e Markdown 格式的段落. ","date":"2019-12-01","objectID":"/markdown/:5:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/markdown/"},{"categories":["Markdown"],"content":"6 强调 ","date":"2019-12-01","objectID":"/markdown/:6:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/markdown/"},{"categories":["Markdown"],"content":"加粗 用于强调带有较粗字体的文本片段. 以下文本片段会被 渲染为粗体. **渲染为粗体** __渲染为粗体__ 输出的 HTML 看起来像这样: \u003cstrong\u003e渲染为粗体\u003c/strong\u003e ","date":"2019-12-01","objectID":"/markdown/:6:1","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/markdown/"},{"categories":["Markdown"],"content":"斜体 用于强调带有斜体的文本片段. 以下文本片段被 渲染为斜体. *渲染为斜体* _渲染为斜体_ 输出的 HTML 看起来像这样: \u003cem\u003e渲染为斜体\u003c/em\u003e ","date":"2019-12-01","objectID":"/markdown/:6:2","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/markdown/"},{"categories":["Markdown"],"content":"删除线 按照 GFMGitHub flavored Markdown 你可以使用删除线. ~~这段文本带有删除线.~~ 呈现的输出效果如下: 这段文本带有删除线. 输出的 HTML 看起来像这样: \u003cdel\u003e这段文本带有删除线.\u003c/del\u003e ","date":"2019-12-01","objectID":"/markdown/:6:3","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/markdown/"},{"categories":["Markdown"],"content":"组合 加粗, 斜体, 和删除线可以 组合使用. ***加粗和斜体*** ~~**删除线和加粗**~~ ~~*删除线和斜体*~~ ~~***加粗, 斜体和删除线***~~ 呈现的输出效果如下: 加粗和斜体 删除线和加粗 删除线和斜体 加粗, 斜体和删除线 输出的 HTML 看起来像这样: \u003cem\u003e\u003cstrong\u003e加粗和斜体\u003c/strong\u003e\u003c/em\u003e \u003cdel\u003e\u003cstrong\u003e删除线和加粗\u003c/strong\u003e\u003c/del\u003e \u003cdel\u003e\u003cem\u003e删除线和斜体\u003c/em\u003e\u003c/del\u003e \u003cdel\u003e\u003cem\u003e\u003cstrong\u003e加粗, 斜体和删除线\u003c/strong\u003e\u003c/em\u003e\u003c/del\u003e ","date":"2019-12-01","objectID":"/markdown/:6:4","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/markdown/"},{"categories":["Markdown"],"content":"7 引用 用于在文档中引用其他来源的内容块. 在要引用的任何文本之前添加 \u003e: \u003e **Fusion Drive** combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. 呈现的输出效果如下: Fusion Drive combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. 输出的 HTML 看起来像这样: \u003cblockquote\u003e \u003cp\u003e \u003cstrong\u003eFusion Drive\u003c/strong\u003e combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. \u003c/p\u003e \u003c/blockquote\u003e 引用也可以嵌套: \u003e Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue. Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. \u003e\u003e Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor odio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam. 呈现的输出效果如下: Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue. Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor odio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam. ","date":"2019-12-01","objectID":"/markdown/:7:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/markdown/"},{"categories":["Markdown"],"content":"8 列表 ","date":"2019-12-01","objectID":"/markdown/:8:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/markdown/"},{"categories":["Markdown"],"content":"无序列表 一系列项的列表, 其中项的顺序没有明显关系. 你可以使用以下任何符号来表示无序列表中的项: * 一项内容 - 一项内容 + 一项内容 例如: * Lorem ipsum dolor sit amet * Consectetur adipiscing elit * Integer molestie lorem at massa * Facilisis in pretium nisl aliquet * Nulla volutpat aliquam velit * Phasellus iaculis neque * Purus sodales ultricies * Vestibulum laoreet porttitor sem * Ac tristique libero volutpat at * Faucibus porta lacus fringilla vel * Aenean sit amet erat nunc * Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Phasellus iaculis neque Purus sodales ultricies Vestibulum laoreet porttitor sem Ac tristique libero volutpat at Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem 输出的 HTML 看起来像这样: \u003cul\u003e \u003cli\u003eLorem ipsum dolor sit amet\u003c/li\u003e \u003cli\u003eConsectetur adipiscing elit\u003c/li\u003e \u003cli\u003eInteger molestie lorem at massa\u003c/li\u003e \u003cli\u003eFacilisis in pretium nisl aliquet\u003c/li\u003e \u003cli\u003eNulla volutpat aliquam velit \u003cul\u003e \u003cli\u003ePhasellus iaculis neque\u003c/li\u003e \u003cli\u003ePurus sodales ultricies\u003c/li\u003e \u003cli\u003eVestibulum laoreet porttitor sem\u003c/li\u003e \u003cli\u003eAc tristique libero volutpat at\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003eFaucibus porta lacus fringilla vel\u003c/li\u003e \u003cli\u003eAenean sit amet erat nunc\u003c/li\u003e \u003cli\u003eEget porttitor lorem\u003c/li\u003e \u003c/ul\u003e ","date":"2019-12-01","objectID":"/markdown/:8:1","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/markdown/"},{"categories":["Markdown"],"content":"有序列表 一系列项的列表, 其中项的顺序确实很重要. 1. Lorem ipsum dolor sit amet 2. Consectetur adipiscing elit 3. Integer molestie lorem at massa 4. Facilisis in pretium nisl aliquet 5. Nulla volutpat aliquam velit 6. Faucibus porta lacus fringilla vel 7. Aenean sit amet erat nunc 8. Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem 输出的 HTML 看起来像这样: \u003col\u003e \u003cli\u003eLorem ipsum dolor sit amet\u003c/li\u003e \u003cli\u003eConsectetur adipiscing elit\u003c/li\u003e \u003cli\u003eInteger molestie lorem at massa\u003c/li\u003e \u003cli\u003eFacilisis in pretium nisl aliquet\u003c/li\u003e \u003cli\u003eNulla volutpat aliquam velit\u003c/li\u003e \u003cli\u003eFaucibus porta lacus fringilla vel\u003c/li\u003e \u003cli\u003eAenean sit amet erat nunc\u003c/li\u003e \u003cli\u003eEget porttitor lorem\u003c/li\u003e \u003c/ol\u003e 技巧\r如果你对每一项使用 1., Markdown 将自动为每一项编号. 例如: 1. Lorem ipsum dolor sit amet 1. Consectetur adipiscing elit 1. Integer molestie lorem at massa 1. Facilisis in pretium nisl aliquet 1. Nulla volutpat aliquam velit 1. Faucibus porta lacus fringilla vel 1. Aenean sit amet erat nunc 1. Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem ","date":"2019-12-01","objectID":"/markdown/:8:2","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/markdown/"},{"categories":["Markdown"],"content":"任务列表 任务列表使你可以创建带有复选框的列表. 要创建任务列表, 请在任务列表项之前添加破折号 (-) 和带有空格的方括号 ([ ]). 要选择一个复选框，请在方括号之间添加 x ([x]). - [x] Write the press release - [ ] Update the website - [ ] Contact the media 呈现的输出效果如下: Write the press release Update the website Contact the media ","date":"2019-12-01","objectID":"/markdown/:8:3","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/markdown/"},{"categories":["Markdown"],"content":"9 代码 ","date":"2019-12-01","objectID":"/markdown/:9:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/markdown/"},{"categories":["Markdown"],"content":"行内代码 用 ` 包装行内代码段. 在这个例子中, `\u003csection\u003e\u003c/section\u003e` 会被包裹成 **代码**. 呈现的输出效果如下: 在这个例子中, \u003csection\u003e\u003c/section\u003e 会被包裹成 代码. 输出的 HTML 看起来像这样: \u003cp\u003e 在这个例子中, \u003ccode\u003e\u0026lt;section\u0026gt;\u0026lt;/section\u0026gt;\u003c/code\u003e 会被包裹成 \u003cstrong\u003e代码\u003c/strong\u003e. \u003c/p\u003e ","date":"2019-12-01","objectID":"/markdown/:9:1","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/markdown/"},{"categories":["Markdown"],"content":"缩进代码 将几行代码缩进至少四个空格，例如: // Some comments line 1 of code line 2 of code line 3 of code 呈现的输出效果如下: // Some comments line 1 of code line 2 of code line 3 of code 输出的 HTML 看起来像这样: \u003cpre\u003e \u003ccode\u003e // Some comments line 1 of code line 2 of code line 3 of code \u003c/code\u003e \u003c/pre\u003e ","date":"2019-12-01","objectID":"/markdown/:9:2","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/markdown/"},{"categories":["Markdown"],"content":"围栏代码块 使用 “围栏” ``` 来生成一段带有语言属性的代码块. ```markdown Sample text here... ``` 输出的 HTML 看起来像这样: \u003cpre language-html\u003e \u003ccode\u003eSample text here...\u003c/code\u003e \u003c/pre\u003e ","date":"2019-12-01","objectID":"/markdown/:9:3","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/markdown/"},{"categories":["Markdown"],"content":"语法高亮 GFMGitHub Flavored Markdown 也支持语法高亮. 要激活它，只需在第一个代码 “围栏” 之后直接添加你要使用的语言的文件扩展名, ```js, 语法高亮显示将自动应用于渲染的 HTML 中. 例如, 在以下 JavaScript 代码中应用语法高亮: ```js grunt.initConfig({ assemble: { options: { assets: 'docs/assets', data: 'src/data/*.{json,yml}', helpers: 'src/custom-helpers.js', partials: ['src/partials/**/*.{hbs,md}'] }, pages: { options: { layout: 'default.hbs' }, files: { './': ['src/templates/pages/index.hbs'] } } } }; ``` 呈现的输出效果如下: grunt.initConfig({ assemble: { options: { assets: 'docs/assets', data: 'src/data/*.{json,yml}', helpers: 'src/custom-helpers.js', partials: ['src/partials/**/*.{hbs,md}'] }, pages: { options: { layout: 'default.hbs' }, files: { './': ['src/templates/pages/index.hbs'] } } } }; 注意\rHugo 文档中的 语法高亮页面 介绍了有关语法高亮的更多信息, 包括语法高亮的 shortcode.\r","date":"2019-12-01","objectID":"/markdown/:9:4","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/markdown/"},{"categories":["Markdown"],"content":"10 表格 通过在每个单元格之间添加竖线作为分隔线, 并在标题下添加一行破折号 (也由竖线分隔) 来创建表格. 注意, 竖线不需要垂直对齐. | Option | Description | | ------ | ----------- | | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | 呈现的输出效果如下: Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. 输出的 HTML 看起来像这样: \u003ctable\u003e \u003cthead\u003e \u003ctr\u003e \u003cth\u003eOption\u003c/th\u003e \u003cth\u003eDescription\u003c/th\u003e \u003c/tr\u003e \u003c/thead\u003e \u003ctbody\u003e \u003ctr\u003e \u003ctd\u003edata\u003c/td\u003e \u003ctd\u003epath to data files to supply the data that will be passed into templates.\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eengine\u003c/td\u003e \u003ctd\u003eengine to be used for processing templates. Handlebars is the default.\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eext\u003c/td\u003e \u003ctd\u003eextension to be used for dest files.\u003c/td\u003e \u003c/tr\u003e \u003c/tbody\u003e \u003c/table\u003e 文本右对齐或居中对齐\r在任何标题下方的破折号右侧添加冒号将使该列的文本右对齐. 在任何标题下方的破折号两边添加冒号将使该列的对齐文本居中. | Option | Description | |:------:| -----------:| | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | 呈现的输出效果如下: Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. ","date":"2019-12-01","objectID":"/markdown/:10:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/markdown/"},{"categories":["Markdown"],"content":"11 链接 ","date":"2019-12-01","objectID":"/markdown/:11:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/markdown/"},{"categories":["Markdown"],"content":"基本链接 \u003chttps://assemble.io\u003e \u003ccontact@revolunet.com\u003e [Assemble](https://assemble.io) 呈现的输出效果如下 (将鼠标悬停在链接上，没有提示): https://assemble.io contact@revolunet.com Assemble 输出的 HTML 看起来像这样: \u003ca href=\"https://assemble.io\"\u003ehttps://assemble.io\u003c/a\u003e \u003ca href=\"mailto:contact@revolunet.com\"\u003econtact@revolunet.com\u003c/a\u003e \u003ca href=\"https://assemble.io\"\u003eAssemble\u003c/a\u003e ","date":"2019-12-01","objectID":"/markdown/:11:1","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/markdown/"},{"categories":["Markdown"],"content":"添加一个标题 [Upstage](https://github.com/upstage/ \"Visit Upstage!\") 呈现的输出效果如下 (将鼠标悬停在链接上，会有一行提示): Upstage 输出的 HTML 看起来像这样: \u003ca href=\"https://github.com/upstage/\" title=\"Visit Upstage!\"\u003eUpstage\u003c/a\u003e ","date":"2019-12-01","objectID":"/markdown/:11:2","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/markdown/"},{"categories":["Markdown"],"content":"定位标记 定位标记使你可以跳至同一页面上的指定锚点. 例如, 每个章节: ## Table of Contents * [Chapter 1](#chapter-1) * [Chapter 2](#chapter-2) * [Chapter 3](#chapter-3) 将跳转到这些部分: ## Chapter 1 \u003ca id=\"chapter-1\"\u003e\u003c/a\u003e Content for chapter one. ## Chapter 2 \u003ca id=\"chapter-2\"\u003e\u003c/a\u003e Content for chapter one. ## Chapter 3 \u003ca id=\"chapter-3\"\u003e\u003c/a\u003e Content for chapter one. 注意\r定位标记的位置几乎是任意的. 因为它们并不引人注目, 所以它们通常被放在同一行了.\r","date":"2019-12-01","objectID":"/markdown/:11:3","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/markdown/"},{"categories":["Markdown"],"content":"12 脚注 脚注使你可以添加注释和参考, 而不会使文档正文混乱. 当你创建脚注时, 会在添加脚注引用的位置出现带有链接的上标编号. 读者可以单击链接以跳至页面底部的脚注内容. 要创建脚注引用, 请在方括号中添加插入符号和标识符 ([^1]). 标识符可以是数字或单词, 但不能包含空格或制表符. 标识符仅将脚注引用与脚注本身相关联 - 在脚注输出中, 脚注按顺序编号. 在中括号内使用插入符号和数字以及用冒号和文本来添加脚注内容 ([^1]：这是一段脚注). 你不一定要在文档末尾添加脚注. 可以将它们放在除列表, 引用和表格等元素之外的任何位置. 这是一个数字脚注[^1]. 这是一个带标签的脚注[^label] [^1]: 这是一个数字脚注 [^label]: 这是一个带标签的脚注 这是一个数字脚注1. 这是一个带标签的脚注2 ","date":"2019-12-01","objectID":"/markdown/:12:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/markdown/"},{"categories":["Markdown"],"content":"13 图片 图片的语法与链接相似, 但包含一个在前面的感叹号. ![Minion](https://octodex.github.com/images/minion.png) 或者: ![Alt text](https://octodex.github.com/images/stormtroopocat.jpg \"The Stormtroopocat\") The Stormtroopocat\r像链接一样, 图片也具有脚注样式的语法: ![Alt text][id] The Dojocat\r稍后在文档中提供参考内容, 用来定义 URL 的位置: [id]: https://octodex.github.com/images/dojocat.jpg \"The Dojocat\" 技巧\rLoveIt 主题提供了一个包含更多功能的 图片的 shortcode.\r这是一个数字脚注 ↩︎ 这是一个带标签的脚注 ↩︎ ","date":"2019-12-01","objectID":"/markdown/:13:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/markdown/"},{"categories":["狍噗噗带你玩转牛客!"],"content":"Nowcoder","date":"2023-07-08","objectID":"/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B07.8/","tags":["Nowcoder","狍噗噗","数据结构","哈希表","双指针"],"title":"[学习日记] 哈希表专题","uri":"/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B07.8/"},{"categories":["狍噗噗带你玩转牛客!"],"content":"Nowcoder 面试必刷Top101 BM50 两数之和 BM52 数组中只出现一次的两个数字 BM54 三数之和 [学习日记] 2023.07.08 哈希表专题 ","date":"2023-07-08","objectID":"/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B07.8/:0:0","tags":["Nowcoder","狍噗噗","数据结构","哈希表","双指针"],"title":"[学习日记] 哈希表专题","uri":"/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B07.8/"},{"categories":["狍噗噗带你玩转牛客!"],"content":"BM50 两数之和 与Leetcode每日一题167. 两数之和 II - 输入有序数组同解 题目描述： 给出一个整型数组 numbers 和一个目标值 target，请在数组中找出两个加起来等于目标值的数的下标，返回的下标按升序排列。 （注：返回的数组下标从1开始算起，保证target一定可以由数组里面2个数字相加得到） 数据范围：$2 \\leq len(numbers) \\leq 10^5$， $-10 \\leq numbers_i \\leq 10^9$， $0 \\leq target \\leq 10^9$。 要求：时间复杂度$O(n)$，空间复杂度$O(nlogn)$ 题目链接：BM50 两数之和 示例 1： 输入：[3,2,4],6\r输出：[2,3]\r解释：因为 2+4=6 ，而 2的下标为2 ， 4的下标为3 ，又因为 下标2 \u003c 下标3 ，所以返回[2,3]\r示例 2: 输入：[20,70,110,150],90\r输出：[1,2]\r解释：20+70=90\r题目难度： 简单 题目解读： 题目给出的是一个数组和一个目标值，需要我们在数组中找到两个加起来等于目标值的数组元素的下标，且下标要按照升序排列，从1开始； 看到这种题目可能会想到用直接遍历的方式求解（两层循环），但暴力求解的时间复杂度是 $O(n^2)$，空间复杂度为 $O(1)$，因为未申请额外空间； 显然暴力求解的方法无法达到时间复杂度的要求限制，由此应当想到使用 哈希表的方法，使用额外的空间来降低时间复杂度； 哈希表是一种根据关键码（key）直接访问值（value）的一种数据结构。这种直接访问意味着只要知道key就能在Q(1)时间内得到value，因此哈希表经常被用来统计频率、快速检验某个元素是否出现过等场景； 解题思路：暴力求解的方法是将两数之和与target进行匹配，不妨做减法，遍历数组，如果没有匹配到 target-当前值 ，就将当前值存入哈希表（没有找到能与他配对的值，可能在后面），如果有，返回该数字的下标和当前值的下标即可（哈希表中的数索引值一定比当前值的索引值小）。 ","date":"2023-07-08","objectID":"/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B07.8/:1:0","tags":["Nowcoder","狍噗噗","数据结构","哈希表","双指针"],"title":"[学习日记] 哈希表专题","uri":"/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B07.8/"},{"categories":["狍噗噗带你玩转牛客!"],"content":"代码实现 #include \u003cunordered_map\u003e class Solution { public: /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * * @param numbers int整型vector * @param target int整型 * @return int整型vector */ vector\u003cint\u003e twoSum(vector\u003cint\u003e\u0026 numbers, int target) { // write code here vector\u003cint\u003e res; unordered_map\u003cint, int\u003e hash; for(int i=0;i\u003cnumbers.size();i++) { int temp=target-numbers[i]; if(hash.find(temp)==hash.end()) { hash[numbers[i]]=i;//存入下标 } else { res.push_back(hash[temp]+1); res.push_back(i+1); break; } }return res; } }; ","date":"2023-07-08","objectID":"/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B07.8/:1:1","tags":["Nowcoder","狍噗噗","数据结构","哈希表","双指针"],"title":"[学习日记] 哈希表专题","uri":"/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B07.8/"},{"categories":["狍噗噗带你玩转牛客!"],"content":"BM52 组合中只出现一次的两个数字 题目描述： 一个整型数组里除了两个数字只出现一次，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。 数据范围：数组长度 $2 \\leq n \\leq 10^3$， 数组中每个数的大小 $0 \\leq val \\leq 10^6$。 要求：时间复杂度$O(n)$，空间复杂度$O(1)$，输出时按非降序排列。 题目链接：BM52 数组中只出现一次的两个数字 示例 1： 输入：[1,4,1,6]\r输出：[4,6]\r解释：返回的结果中较小的数排在前面\r示例 2: 输入：[1,2,3,3,2,9]\r输出：[1,9]\r题目难度： 中等 题目解读： 题目给定的数组中有且仅有两个数字只出现过一次，显然用哈希表记录数字出现过的次数能快速解决此问题； 需要注意的是整型数组可能是无序的，而题目要求输出时按非降序排列，所以需要将vector数组排列一下。 ","date":"2023-07-08","objectID":"/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B07.8/:2:0","tags":["Nowcoder","狍噗噗","数据结构","哈希表","双指针"],"title":"[学习日记] 哈希表专题","uri":"/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B07.8/"},{"categories":["狍噗噗带你玩转牛客!"],"content":"代码实现 #include \u003cunordered_map\u003e class Solution { public: /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * * @param nums int整型vector * @return int整型vector */ vector\u003cint\u003e FindNumsAppearOnce(vector\u003cint\u003e\u0026 nums) { // write code here unordered_map\u003cint, int\u003e hash; vector\u003cint\u003e res; for(int i=0;i\u003cnums.size();i++) { hash[nums[i]]++; } for(int i=0;i\u003cnums.size();i++) { if(hash[nums[i]]==1) res.push_back(nums[i]); if(res.size()==2) break; } sort(res.begin(),res.end()); return res; } }; ","date":"2023-07-08","objectID":"/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B07.8/:2:1","tags":["Nowcoder","狍噗噗","数据结构","哈希表","双指针"],"title":"[学习日记] 哈希表专题","uri":"/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B07.8/"},{"categories":["狍噗噗带你玩转牛客!"],"content":"BM54 三数之和 题目描述： 给出一个有n个元素的数组S，S中是否有元素a,b,c满足a+b+c=0？找出数组S中所有满足条件的三元组。 数据范围：$0 \\leq n \\leq 1000$，数组中各个元素值满足 $|val| \\leq 100$ 要求：时间复杂度$O(n^2)$，空间复杂度$O(n^2)$ 注意：三元组$(a,b,c)$中的元素必须按非降序排列（即$a \\leq b \\leq c$），且解集中不能包含重复的三元组。 题目链接：BM54 三数之和 示例 1： 输入：[0]\r输出：[]\r示例 2: 输入：[-2,0,1,1,2]\r输出：[[-2,0,2],[-2,1,1]]\r示例 3： 输入：[-10,0,10,20,-10,-40]\r输出：[[-10,-10,20],[-10,0,10]]\r题目难度： 中等 题目解读： 与两数之和那题相同，最朴素的做法是先排序然后通过三重循环寻找答案，但显然达不到时间复杂度的要求； 直接找三个数的和为某个数比较麻烦，所以可以拆分一下：如果找到某个数$a$，要找到与之对应的两外两个数，三个数之和为0，也就是找到另外两个数之和为$-a$即可； 因为输出的三元组内部必须是有序的，所以可以优先对原数组进行排列，这样每次取到一个最小数$a$，只需要在后续的子数组中找到两个之和为$-a$就可以了，可以用双指针缩小区间，可以将一些完全不可能的情况抛弃； 双指针是在遍历对象的过程中，不是普通的使用单个指针进行访问，而是使用两个指针（甚至是多个），两个指针或是同方向访问两个链表，或是同方向访问一个链表（快慢指针），或是相反方向扫描链表（对撞指针），从而达到目的；本题可以用对撞指针求解； 解题思路：先对数组进行排序；得到有序数组后，遍历该数组，对于每个遍历到的元素应当是三元组中最小的一个，那么另外两个一定在后面；利用双指针在右边的子数组中寻找有没有相加之和满足要求的数对存在，双指针分别指向剩余子数组的首尾，如果两者相加为目标值，则记录该三元组，遍历出所有满足要求的数对；如果二者相加的大于目标值，说明右指针太大了，将其左移缩小，相反如果二者相加小于目标值，说明左指针太小了，将其右移扩大，指导两个指针相遇，说明剩余子数组找完了。 需要注意的是对于三个数字都要判断是否相邻有重复的情况，要去重。 ","date":"2023-07-08","objectID":"/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B07.8/:3:0","tags":["Nowcoder","狍噗噗","数据结构","哈希表","双指针"],"title":"[学习日记] 哈希表专题","uri":"/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B07.8/"},{"categories":["狍噗噗带你玩转牛客!"],"content":"代码实现 class Solution { public: /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * * @param num int整型vector * @return int整型vector\u003cvector\u003c\u003e\u003e */ vector\u003cvector\u003cint\u003e \u003e threeSum(vector\u003cint\u003e\u0026 num) { // write code here vector\u003cvector\u003cint\u003e\u003e res; if(num.size()\u003c3) return res; sort(num.begin(),num.end()); for(int k=0;k\u003cnum.size()-2;k++) { if(k\u003e=1 \u0026\u0026 num[k]==num[k-1]) continue; int i=k+1; int j=num.size()-1; while(i\u003cj) { if(num[i]+num[j]==-num[k])//找到了 { res.push_back({num[k],num[i],num[j]}); //去重 while(num[i+1]==num[i]) i++; while(num[j-1]==num[j]) j--; //中间还可能会有 i++; j--; } else if(num[i]+num[j]\u003e-num[k])//大了 { j--; } else {//小了 i++; } } } return res; } }; ","date":"2023-07-08","objectID":"/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B07.8/:3:1","tags":["Nowcoder","狍噗噗","数据结构","哈希表","双指针"],"title":"[学习日记] 哈希表专题","uri":"/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B07.8/"},{"categories":["狍噗噗带你玩转力扣!"],"content":"Leetcode","date":"2023-04-27","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%984.27/","tags":["Leetcode - 狍噗噗 - 字符串 - 动态规划"],"title":"[每日一题] 1048.最长字符串链","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%984.27/"},{"categories":["狍噗噗带你玩转力扣!"],"content":"Leetcode 每日一题 1048.最长字符串链 每日一题 2023.04.27 题目描述： 给出一个单词数组 $ words $ ，其中每个单词都由小写英文字母组成。 如果我们可以 不改变其他字符的顺序 ，在 $ word_A $ 的任何地方添加 恰好一个 字母使其变成 $ word_B$ ，那么我们认为 $word_A$ 是 $word_B$ 的前身 。例如，\"abc\" 是 \"abac\" 的前身，而 \"cba\" 不是 \"bcad\" 的前身。 词链是单词 $ [word_1, word_2, …, word_k] $ 组成的序列，$ k \u003e= 1 $，其中 $ word_1$ 是 $ word_2 $ 的前身，$ word_2 $ 是 $ word_3 $ 的前身，依此类推。一个单词通常是 $ k = 1 $ 的 单词链 。 从给定单词列表 $ words $ 中选择单词组成词链，返回 词链 的最长可能长度 。 题目链接：1048.最长字符串链 示例 1： 输入：words = [\"a\",\"b\",\"ba\",\"bca\",\"bda\",\"bdca\"]\r输出：4\r解释：最长单词链之一为 [\"a\",\"ba\",\"bda\",\"bdca\"]\r示例 2: 输入：words = [\"xbc\",\"pcxbcf\",\"xb\",\"cxbc\",\"pcxbc\"]\r输出：5\r解释：所有的单词都可以放入单词链 [\"xb\", \"xbc\", \"cxbc\", \"pcxbc\", \"pcxbcf\"].\r示例 3: 输入：words = [\"abcd\",\"dbqca\"]\r输出：1\r解释：字链[\"abcd\"]是最长的字链之一。[\"abcd\"，\"dbqca\"]不是一个有效的单词链，因为字母的顺序被改变了。\r题目难度： 中等 题目解读： 看到求解最长链长度的问题，首先反应到可以使用动态规划，也就是用$ dp $数组来记录选择哪个字符串作为当前字符串的前身才能使得字符串链的长度最长； 本题可以直接使用unordered_map\u003cstring,int\u003e的数据结构，也就是用哈希表$ dp $存储数组中每个字符串的最长字符串链长度； 可以通过删掉当前字符串中任一位置的字符来匹配前身； 通过题目描述可知，最长字符串链中的字符串元素一定是按字符串长度递增的，并且后一个元素长度一定比前一个元素长度多1，所以可以先对$ words $数组做排序处理，按照字符串长度进行升序排列。 ","date":"2023-04-27","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%984.27/:0:0","tags":["Leetcode - 狍噗噗 - 字符串 - 动态规划"],"title":"[每日一题] 1048.最长字符串链","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%984.27/"},{"categories":["狍噗噗带你玩转力扣!"],"content":"代码实现 bool cmp(const string \u0026a,const string \u0026b) { return a.size()\u003cb.size(); } class Solution { public: int longestStrChain(vector\u003cstring\u003e\u0026 words) { sort(words.begin(),words.end(),cmp); int ans=0; unordered_map\u003cstring,int\u003e dp; for(auto word:words) { int cnt=1; for(int i=0;i\u003cword.size();i++) { string subword=word.substr(0,i)+word.substr(i+1);//去掉第i个字符 cnt=max(cnt,dp[subword]+1); } dp[word]=cnt; ans=max(ans,cnt); } return ans; } }; ","date":"2023-04-27","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%984.27/:0:1","tags":["Leetcode - 狍噗噗 - 字符串 - 动态规划"],"title":"[每日一题] 1048.最长字符串链","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%984.27/"},{"categories":["狍噗噗带你玩转力扣!"],"content":"Leetcode","date":"2023-04-13","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%984.13/","tags":["Leetcode - 狍噗噗 - 哈希表 - map"],"title":"[每日一题] 2404.出现最频繁的偶数元素","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%984.13/"},{"categories":["狍噗噗带你玩转力扣!"],"content":"Leetcode 每日一题 2404.出现最频繁的偶数元素 Newcoder 类似题目 HJ23.删除字符串中出现次数最少的字符 每日一题 2023.04.13 题目描述： 给你一个整数数组 nums ，返回出现最频繁的偶数元素。 如果存在多个满足条件的元素，只需要返回 最小 的一个。如果不存在这样的元素，返回 -1 。 题目链接：1019.链表中的下一个更大节点 示例 1： 输入：nums = [0,1,2,2,4,4,1]\r输出：2\r解释：数组中的偶数元素为 0、2 和 4 ，在这些元素中，2 和 4 出现次数最多。返回最小的那个，即返回 2 。\r示例 2： 输入：nums = [4,4,4,9,2,4]\r输出：4\r解释：4 是出现最频繁的偶数元素。\r示例 3： 输入：nums = [29,47,21,41,13,37,25,7]\r输出：-1\r解释：不存在偶数元素。\r题目难度： 简单 题目解读： 需要记录偶数元素和元素出现个数对，类似于记录一个哈希表，于是通过最近刷题经验，可以想到可以利用STL的map容器解决； 需要注意的是map容器的操作以及map容器是天然按照第一个值的（pair左边的值）字典序进行排列的，该值是map的主键，是不可以重复出现的，如果是int型的就会按照第一个值的大小从小到大排列。 由于map是按主键大小从小到大排列的，所以根据题目要求输出value值相同的较大主键值，应当从右往左使用迭代器遍历map。 ","date":"2023-04-13","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%984.13/:0:0","tags":["Leetcode - 狍噗噗 - 哈希表 - map"],"title":"[每日一题] 2404.出现最频繁的偶数元素","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%984.13/"},{"categories":["狍噗噗带你玩转力扣!"],"content":"代码实现 class Solution { public: int mostFrequentEven(vector\u003cint\u003e\u0026 nums) { map\u003cint,int\u003em; for(int i=0;i\u003cnums.size();i++) { if(nums[i]%2==0) { m[nums[i]]++; } } map\u003cint,int\u003e::iterator it; int res=-1; int max=0; for(auto it=m.rbegin();it!=m.rend();it++)//使用迭代器从右往左遍历 { //cout\u003c\u003cit-\u003efirst\u003c\u003c\" \"\u003c\u003cendl; //例如对于示例1 map里是[[2,2],[4,2]] //对于示例2 map里存放的是[[2,1],[4,4]] if(it-\u003esecond\u003e=max) { max=it-\u003esecond; res=it-\u003efirst; } } return res; } }; ","date":"2023-04-13","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%984.13/:0:1","tags":["Leetcode - 狍噗噗 - 哈希表 - map"],"title":"[每日一题] 2404.出现最频繁的偶数元素","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%984.13/"},{"categories":["狍噗噗带你玩转力扣!"],"content":"类似题目 该题与Newcoder里的一题很像，放在一起看看叭！ 题目描述： 实现删除字符串中出现次数最少的字符，若出现次数最少的字符有多个，则把出现次数最少的字符都删除。输出删除这些单词后的字符串，字符串中其它字符保持原来的顺序。 输入描述： 保证输入的字符串仅出现小写字母，不考虑非法输入。 输出描述： 删除字符串中出现次数最少的字符后的字符串。 题目链接：HJ23.删除字符串中出现次数最少的字符 示例 1： 输入： aabcddd\r输出： aaddd\r题目难度： 简单 解题思路： 主要注意map容器的操作，这题是将出现次数最少的都删除，所以从左往右遍历即可。 ","date":"2023-04-13","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%984.13/:0:2","tags":["Leetcode - 狍噗噗 - 哈希表 - map"],"title":"[每日一题] 2404.出现最频繁的偶数元素","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%984.13/"},{"categories":["狍噗噗带你玩转力扣!"],"content":"代码实现 #include \u003calgorithm\u003e #include \u003ciostream\u003e #include \u003cmap\u003e #include \u003cstring\u003e #include \u003cvector\u003e using namespace std; bool cmp(const pair\u003cchar,int\u003e a,const pair\u003cchar,int\u003e b) { return a.second\u003eb.second; } int main() { string str; cin\u003e\u003estr; map\u003cchar,int\u003e m; map\u003cchar,int\u003e::iterator it; for(int i=0;i\u003cstr.size();i++) { m[str[i]]++; } int min=m[str[0]]; for(int i=0;i\u003cstr.size();i++) { if(m[str[i]]\u003cmin) min=m[str[i]];//找到最小的次数 } for(int i=0;i\u003cstr.size();i++) { if(m[str[i]]\u003emin) cout\u003c\u003cstr[i]; } cout\u003c\u003cendl; return 0; } ","date":"2023-04-13","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%984.13/:0:3","tags":["Leetcode - 狍噗噗 - 哈希表 - map"],"title":"[每日一题] 2404.出现最频繁的偶数元素","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%984.13/"},{"categories":["狍噗噗带你玩转力扣!"],"content":"Nowcoder","date":"2023-04-13","objectID":"/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%8D%8E%E4%B8%BA%E9%A2%98%E5%BA%93/","tags":["Nowcoder","狍噗噗","c++"],"title":"[学习日记] 牛客华为笔试题练习","uri":"/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%8D%8E%E4%B8%BA%E9%A2%98%E5%BA%93/"},{"categories":["狍噗噗带你玩转力扣!"],"content":"Nowcoder 华为笔试 易忘点总结 牛客网华为题库： 1、如果使用string字符串，要输入带空格的字符串得使用 getline(cin,str); 2、字符串的大小写转换 #include\u003cstring\u003e #include\u003calgorithm\u003e //string类型 string str; //转大写 transform(str.begin(), str.end(), str.begin(), ::toupper);//1 //第三个参数表示写入的位置 for(int i=0;i\u003cstr.length();i++)//2 str[i]=toupper(str[i]); //转小写 transform(str.begin(), str.end(), str.begin(), ::tolower);//1 for(int i=0;i\u003cstr.length();i++)//2 str[i]=tolower(str[i]); //char类型 char ch; ch=toupper(ch); ch=tolower(ch); 3、字符串前后翻转 #include\u003calgorithm\u003e string str=\"hello world\"; reverse(str.begin(),str.end()); 4、字符与整型转换 string str; int a; str=to_string(a);//整数转为string //string字符串转整数---带进制 string str=\"0xAA\"; a=stoi(str,nullptr,16);//a=170 string str=\"11\"; a=stoi(str);//a=11 a=stoi(str,nullptr,8);//a=9 a=stoi(str,nullptr,2);//a=3 a=stoi(str,nullptr,16);//a=17 //第三个参数指字符串表示是几进制的 //第二个参数是一个pos指针，一般是nullptr 5、浮点型数转整型数 double a=4.6; int b=int(a);//b=4强制类型转换只保留整数部分，不进行四舍五入 int c=int(a+0.5);//c=5四舍五入的保留整数 6、STL容器map的使用，适合用于处理二维数组型的，坐标那种 #include\u003cmap\u003e //定义，第一个元素是map的键，第二个元素是值，键不可重复 map\u003cint,string\u003em;//map\u003cstring,string\u003em; //插入元素，两种插入方法皆可 m.insert(pair\u003cint,string\u003e(5,'c')); m[123]=\"cc\"; //访问元素 //第一种是通过下标访问 m[5]='c'; //第二种是通过迭代器进行访问 map\u003cint,string\u003e::iterator it; //利用迭代器遍历 for(it=m.begin();it!=m.end();it++) { cout\u003c\u003cit-\u003efirst\u003c\u003c\" \"\u003c\u003cit-\u003esecond\u003c\u003cendl; //迭代器的first属性对应键值，second属性 } 7、string操作 #include\u003cstring\u003e #include\u003calgorithm\u003e string str=\"123451\"; //翻转string reverse(str.begin(),str.end()); //寻找string中的元素 int pos1=str.find('1');//pos1=0 int pos4=str.rfind('1');//pos4=5,rfind函数是从右向左找 int pos2=str.find(\"123\");//pos2=0，返回第一个元素的下标 string a='c'; int pos3=str.find(a);//pos3=npos，代表没有找到该字符 //输出 cout\u003c\u003cstr\u003c\u003cendl;//可以直接cout，char*数组的话得遍历输出 8、vector操作 vector\u003cstring\u003ev{\"I\",\"am\",\"a\",\"boy\"}; ","date":"2023-04-13","objectID":"/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%8D%8E%E4%B8%BA%E9%A2%98%E5%BA%93/:0:0","tags":["Nowcoder","狍噗噗","c++"],"title":"[学习日记] 牛客华为笔试题练习","uri":"/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%8D%8E%E4%B8%BA%E9%A2%98%E5%BA%93/"},{"categories":["狍噗噗带你玩转力扣!"],"content":"Leetcode","date":"2023-04-10","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%984.10/","tags":["Leetcode","狍噗噗","小猪崽","链表","单调栈"],"title":"[每日一题] 1019.链表中的下一个更大节点","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%984.10/"},{"categories":["狍噗噗带你玩转力扣!"],"content":"Leetcode 每日一题 1019.链表中的下一个更大节点 每日一题 2023.04.10 题目描述： 给定一个长度为 n 的链表 head，对于列表中的每个节点，查找下一个更大节点的值。也就是说，对于每个节点，找到它旁边的第一个节点的值，这个节点的值 严格大于 它的值。 返回一个整数数组 answer ，其中 answer[i] 是第 i 个节点( 从1开始 )的下一个更大的节点的值。如果第 i 个节点没有下一个更大的节点，设置 answer[i] = 0 。 题目链接：1019.链表中的下一个更大节点 题目难度： 中等 ","date":"2023-04-10","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%984.10/:0:0","tags":["Leetcode","狍噗噗","小猪崽","链表","单调栈"],"title":"[每日一题] 1019.链表中的下一个更大节点","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%984.10/"},{"categories":["狍噗噗带你玩转力扣!"],"content":"循环双指针 题目解读： 没什么想法，感觉两次循环是最容易想到的方法，虽然效率肯定不怎么样，但能做出来就行吧！ 那么就用两个tmp节点来进行循环，tmp1节点从head链表的第一个节点开始，为head链表里的每个节点寻找下一个更大节点； tmp2节点从tmp1的下一个节点开始，一直到链表尾部，直到找到第一个值比tmp1节点值更大的节点，将该节点的val属性值存入res容器的对应位置； 维护一个布尔值find，记录当前tmp1节点是否能够找到下一个更大节点，如果tmp2循环至链表尾部仍没有找到，则对应的find值为false，直接在res容器的对应位置存个0即可，代表该节点没有下一个更大节点。 ","date":"2023-04-10","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%984.10/:1:0","tags":["Leetcode","狍噗噗","小猪崽","链表","单调栈"],"title":"[每日一题] 1019.链表中的下一个更大节点","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%984.10/"},{"categories":["狍噗噗带你玩转力扣!"],"content":"代码实现 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: vector\u003cint\u003e nextLargerNodes(ListNode* head) { vector\u003cint\u003e res; ListNode* tmp1=head; while(tmp1!=NULL) { bool find=false; ListNode *tmp2=tmp1-\u003enext; while(tmp2!=NULL) { if(tmp2-\u003eval\u003etmp1-\u003eval) { res.push_back(tmp2-\u003eval); find=true; break; } tmp2=tmp2-\u003enext; } if(!find) res.push_back(0); tmp1=tmp1-\u003enext; } return res; } }; ","date":"2023-04-10","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%984.10/:1:1","tags":["Leetcode","狍噗噗","小猪崽","链表","单调栈"],"title":"[每日一题] 1019.链表中的下一个更大节点","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%984.10/"},{"categories":["狍噗噗带你玩转力扣!"],"content":"单调栈方法 对一个数，想要寻找下一个比他更大的元素，都可以使用单调栈的方法 具体思路如下： 初始化两个列表stack和res： stack表示栈底到栈顶单调递减的栈，存储形式为某节点的值和序号(value, index) res用于返回最终结果，第i个元素即为第i个节点下一个比他更大的元素的值 之后，从头至尾遍历链表各个节点，如当前节点的值大于单调栈栈顶的值，说明当前节点为栈顶元素下一个比他更大的元素 因为单调栈中元素自底向上依次递减，所以轮流比较弹出上一元素后新的栈顶元素与当前节点值大小，直至栈空或当前值小于栈顶元素 有点类似于滑动窗口收缩左节点的意思，当遍历完所有节点后，还在栈中的元素在res中对应值均为默认的0，即未找到下一个比他更大的元素 本题在此基础上还有递归的方法，但目前还没学明白，之后会对回溯递归进一步学习了解 参考链接： 单调栈官方题解 ","date":"2023-04-10","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%984.10/:2:0","tags":["Leetcode","狍噗噗","小猪崽","链表","单调栈"],"title":"[每日一题] 1019.链表中的下一个更大节点","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%984.10/"},{"categories":["狍噗噗带你玩转力扣!"],"content":"代码实现 class Solution: def nextLargerNodes(self, head: Optional[ListNode]) -\u003e List[int]: index = -1 cur = head stack = [] res = [] while cur: index += 1 res.append(0) while stack and stack[-1][0] \u003c cur.val: res[stack[-1][1]] = cur.val stack.pop() stack.append((cur.val, index)) cur = cur.next return res ","date":"2023-04-10","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%984.10/:2:1","tags":["Leetcode","狍噗噗","小猪崽","链表","单调栈"],"title":"[每日一题] 1019.链表中的下一个更大节点","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%984.10/"},{"categories":["狍噗噗带你玩转力扣!"],"content":"Leetcode","date":"2023-04-06","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%984.6/","tags":["Leetcode","狍噗噗","进制转换"],"title":"[每日一题] 1017.负二进制转换","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%984.6/"},{"categories":["狍噗噗带你玩转力扣!"],"content":"Leetcode 每日一题 1017.负二进制转换 每日一题 2023.04.06 题目描述： 给你一个整数 n ，以二进制字符串的形式返回该整数的负二进制（base -2）表示。 注意：除非字符串就是 \"0\"，否则返回的字符串中不能含有前导零。 题目链接：1017.负二进制转换 示例 1： 输入：n = 2 输出：\"110\" 解释：$ (-2)^2 $ + $ (-2)^1 $ = 2 示例 2： 输入：n = 3 输出：\"111\" 解释：$ (-2)^2 $ + $ (-2)^1 $ + $ (-2)^0 $ = 3 示例 3： 输入：n = 4 输出：\"100\" 解释：$ (-2)^2 $ = 4 题目难度： 中等 解题思路： 1.如传统十进制转二进制算法一样用辗转相除法，将余数插入结果字符串中； 2.不同的是要注意c++的 / 运算可能会使得结果为负数，这样就导致下一次除法的余数为负数，不能直接添加进去！那应该怎么办呢！讲不清，直接举个栗子看看（以6为例）： $$ 6=(-2) \\times (-3) +0 $$ $$ -3=(-2) \\times 1 +(-1) $$ 问题出现！二进制字符串里只能出现0和1，那这里出现 $-1$ 应该怎么办！将余数取绝对值转为1，重新计算商（下一步的被除数）即可； $$ -3=(-2)\\times 2+1 $$ 相应的，下一个等式的左边值应重新计算，而不是单纯的$(-3)/ (-2)$，应该是 $ 2=[(-3)-1]/(-2) $; $$ 2=(-2)\\times (-1)+0 $$ $$ (-1)=(-2)\\times1+1 $$ $$ 1=(-2)\\times0+1 $$ 取上述过程的余数可以得到6的负二进制表示为 11010。 ","date":"2023-04-06","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%984.6/:0:0","tags":["Leetcode","狍噗噗","进制转换"],"title":"[每日一题] 1017.负二进制转换","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%984.6/"},{"categories":["狍噗噗带你玩转力扣!"],"content":"代码实现 class Solution { public: string baseNeg2(int n) { string ans=\"\"; if(n==0) ans+='0'; while(n!=0) { int modn=abs(n%-2); if(modn==0) ans+='0'; else ans+='1'; n=(n-modn)/-2; } reverse(ans.begin(),ans.end()); return ans; } }; 彩蛋： loveit显示公式，要在文章前面参数添加参数math: true； 添加空行可以使用html的换行标签：\u003cbr/\u003e。 ","date":"2023-04-06","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%984.6/:0:1","tags":["Leetcode","狍噗噗","进制转换"],"title":"[每日一题] 1017.负二进制转换","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%984.6/"},{"categories":["狍噗噗带你玩转力扣！"],"content":"Leetcode","date":"2023-04-05","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%984.5/","tags":["Leetcode","狍噗噗","公因数"],"title":"[每日一题] 2427.公因子数目","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%984.5/"},{"categories":["狍噗噗带你玩转力扣！"],"content":"Leetcode 每日一题 2427.公因子数目 每日一题 2023.04.05 题目描述 给你两个正整数 a 和 b ，返回 a 和 b 的公因子的数目。如果 x 可以同时整除 a 和 b ，则认为 x 是 a 和 b 的一个公因子 。 题目链接：2427.公因子数目 示例 1： 输入：a = 12, b = 6 输出：4 解释：12 和 6 的公因子是 1、2、3、6 。 示例 2： 输入：a = 25, b = 30 输出：2 解释：25 和 30 的公因子是 1、5 。 题目难度： 简单 解题思路Ⅰ： 找到a和b的较小值minab，因为公因子不可能比任一元素大么； 从1到minab穷举因子，如果能同时整除a和b，则计数器加一。 ","date":"2023-04-05","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%984.5/:0:0","tags":["Leetcode","狍噗噗","公因数"],"title":"[每日一题] 2427.公因子数目","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%984.5/"},{"categories":["狍噗噗带你玩转力扣！"],"content":"代码实现Ⅰ class Solution { public: int commonFactors(int a, int b) { int cnt = 0; int minab = (a\u003c=b)?a:b; for(int i=1;i\u003c=minab;i++) { if(a%i==0 \u0026\u0026 b%i==0) cnt++; } return cnt; } }; 解题思路Ⅱ: 用上述方法固然能够得到答案，但是时间消耗有点高，也就是做了一些无意义的枚举，可以通过先找到 a 与 b 的最大公因数 c （这个最大公因数难道不是枚举来的么），然后遍历 [1,c] 中的整数。 还可以做进一步优化：由于因子一定都是成对出现的，如果 x 是 c 的因子，那么 c\\x 也一定是 c 的因子，因此可以将枚举的范围 进一步缩小。 ","date":"2023-04-05","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%984.5/:0:1","tags":["Leetcode","狍噗噗","公因数"],"title":"[每日一题] 2427.公因子数目","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%984.5/"},{"categories":["狍噗噗带你玩转力扣！"],"content":"代码实现Ⅱ class Solution { public: int commonFactors(int a, int b) { int cnt = 0; int c=gcd(a,b); for(int i=1;i*i\u003c=c;i++) { if(c%i==0) { cnt++; if(i*i!=c) cnt++; } } return cnt; } }; 结果： 执行时间直接超越100% ","date":"2023-04-05","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%984.5/:0:2","tags":["Leetcode","狍噗噗","公因数"],"title":"[每日一题] 2427.公因子数目","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%984.5/"},{"categories":["狍噗噗带你玩转力扣！"],"content":"Leetcode","date":"2023-04-04","objectID":"/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B54.4/","tags":["Leetcode","小猪崽","数组","螺旋矩阵"],"title":"[学习日记] 螺旋矩阵转转转","uri":"/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B54.4/"},{"categories":["狍噗噗带你玩转力扣！"],"content":"Leetcode 螺旋矩阵相关题目 54.螺旋矩阵 59.螺旋矩阵II [学习日记] 2023.04.04 螺旋矩阵转转转 参考链接： 代码随想录：螺旋矩阵Ⅱ ","date":"2023-04-04","objectID":"/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B54.4/:0:0","tags":["Leetcode","小猪崽","数组","螺旋矩阵"],"title":"[学习日记] 螺旋矩阵转转转","uri":"/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B54.4/"},{"categories":["狍噗噗带你玩转力扣！"],"content":"54.螺旋矩阵 题目描述： 给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。 题目链接：54.螺旋矩阵 题目难度： 中等 题目解读： 本题实际上是要求对一个矩阵按指定顺序进行读取 提前接触过螺旋矩阵Ⅱ，因此按照从左到右、从上到下、从右到左、从下到上，四次循环进行遍历 每圈遍历结束后，通过偏移值修改，进入内圈循环，主要难点在于边界的确定，做到不重复不遗漏 考虑到进入内圈，本题我采用的边界如下： 从左到右：头尾都包括 从上到下：包括尾部 从右到左：包括尾部 从下到上：头尾都不包括 ","date":"2023-04-04","objectID":"/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B54.4/:1:0","tags":["Leetcode","小猪崽","数组","螺旋矩阵"],"title":"[学习日记] 螺旋矩阵转转转","uri":"/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B54.4/"},{"categories":["狍噗噗带你玩转力扣！"],"content":"代码实现 class Solution: def spiralOrder(self, matrix: List[List[int]]) -\u003e List[int]: row = len(matrix) col = len(matrix[0]) start_row = 0 start_col = 0 res = [] cnt = 0 total = (row) * (col) offset = 0 while(cnt \u003c total): # print('left-right') for i in range(start_col, col-offset): # print(matrix[start_row][i]) res.append(matrix[start_row][i]) cnt += 1 if cnt == total: return res # print('up to down') for i in range(start_row+1, row-offset): # print(matrix[i][col-offset-1]) res.append(matrix[i][col-offset-1]) cnt += 1 if cnt == total: return res # print('right to left') for i in range(col-offset-2, start_col-1, -1): # print(matrix[row-offset-1][i]) res.append(matrix[row-offset-1][i]) cnt += 1 if cnt == total: return res # print('down to up') for i in range(row-offset-2, start_row, -1): # print(matrix[i][start_col]) res.append(matrix[i][start_col]) cnt += 1 if cnt == total: return res offset += 1 start_row += 1 start_col += 1 ","date":"2023-04-04","objectID":"/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B54.4/:1:1","tags":["Leetcode","小猪崽","数组","螺旋矩阵"],"title":"[学习日记] 螺旋矩阵转转转","uri":"/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B54.4/"},{"categories":["狍噗噗带你玩转力扣！"],"content":"59.螺旋矩阵 II 题目描述： 给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。 题目链接：59.螺旋矩阵II 题目难度： 中等 题目解读： 本题思路基本与上题相同，矩阵固定为n × n的正方形矩阵，个人感觉比螺旋矩阵要简单一点 边界的处理四个方向遍历都是包含头不包括尾，将偏移值offset初始为1，整体代码更美观一点 本题各类矩阵主要区别就是n的奇偶，如果为奇，最后给矩阵中心点赋值，如果为偶，层层递进循环即可 ","date":"2023-04-04","objectID":"/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B54.4/:2:0","tags":["Leetcode","小猪崽","数组","螺旋矩阵"],"title":"[学习日记] 螺旋矩阵转转转","uri":"/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B54.4/"},{"categories":["狍噗噗带你玩转力扣！"],"content":"代码实现 class Solution: def generateMatrix(self, n: int) -\u003e List[List[int]]: start_row = 0 start_col = 0 offset = 1 res = [[0] * n for _ in range(n)] cnt = 1 if n == 1: return [[1]] while(offset \u003c= n//2): # print('left-right') for i in range(start_col, n-offset): res[start_row][i] = cnt cnt += 1 # print(res) for i in range(start_row, n-offset): res[i][n-offset] = cnt cnt += 1 # print(res) for i in range(n-offset, start_col, -1): res[n-offset][i] = cnt cnt += 1 # print(res) for i in range(n-offset, start_row, -1): res[i][start_col] = cnt cnt += 1 # print(res) start_row += 1 start_col += 1 offset += 1 if n%2 != 0: res[n//2][n//2] = cnt return res ","date":"2023-04-04","objectID":"/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B54.4/:2:1","tags":["Leetcode","小猪崽","数组","螺旋矩阵"],"title":"[学习日记] 螺旋矩阵转转转","uri":"/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B54.4/"},{"categories":["狍噗噗带你玩转力扣！"],"content":"题型小结 主要难点即使每次循环遍历的边界确定，可以考虑以含头不含尾、含尾不含头入手，也可以自行定义，不被绕迷糊即可 Python中矩阵的初始化，可以用[[0]*n for _ in range(n)] 生成一个n×n的矩阵: # [0]*n 生成的对应矩阵即为[0,..,0] # [[0]*n] 生成的对应矩阵为[[0,...,0]] # [[0]*n for _ in range(n)] 生成的矩阵为[[0,...,0],...,[0,...,0]] ","date":"2023-04-04","objectID":"/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B54.4/:3:0","tags":["Leetcode","小猪崽","数组","螺旋矩阵"],"title":"[学习日记] 螺旋矩阵转转转","uri":"/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B54.4/"},{"categories":["狍噗噗带你玩转力扣！"],"content":"Leetcode","date":"2023-04-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%984.2/","tags":["Leetcode","小猪崽","动态规划","缓存装饰器"],"title":"[每日一题] 1039.多边形三角剖分的最低得分","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%984.2/"},{"categories":["狍噗噗带你玩转力扣！"],"content":"Leetcode 每日一题 1039.多边形三角剖分的最低得分 每日一题 2023.04.02 题目描述： 你有一个凸的 n 边形，其每个顶点都有一个整数值。给定一个整数数组 values ，其中 values[i] 是第 i 个顶点的值（即 顺时针顺序 ）。 假设将多边形 剖分 为 n - 2 个三角形。对于每个三角形，该三角形的值是顶点标记的乘积，三角剖分的分数是进行三角剖分后所有 n - 2 个三角形的值之和。 返回 多边形进行三角剖分后可以得到的最低分 。 题目链接：1039.多边形三角剖分的最低得分 题目难度： 中等 题目解读： 拿到题目一脸懵 别说写代码了 让我划分三角形解决数学问题都难 直接打开题解 学习一下解题思路 大致如下： 解决方法是基于动态规划 从顶点i到顶点j 有一个隐藏信息即是 总会有一个三角形 会以i到j的连线为边 然后以中间某一点为第三个顶点，所以动态规划就以此为基点展开 每次选择一个顶点k，则会在以i,j,k为顶点的三角形左右，各产生一个多边形，再对多边形进行动态规划递归求解即可 虽说每次进行一个最小值判断，但并不是说每次选择一个值最小的三角形顶点k，实际只是遍历，所以后续需要用到@cache进行缓存 第一次接触缓存装饰器，不用cache提交超时了，使用缓存解决问题，后续对装饰器进行补充学习 ","date":"2023-04-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%984.2/:0:0","tags":["Leetcode","小猪崽","动态规划","缓存装饰器"],"title":"[每日一题] 1039.多边形三角剖分的最低得分","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%984.2/"},{"categories":["狍噗噗带你玩转力扣！"],"content":"代码实现 class Solution: def minScoreTriangulation(self, values: List[int]) -\u003e int: @cache def dfs(i, j): if j == i + 1: return 0 res = inf for k in range(i+1, j): res = min(res, dfs(i, k)+dfs(k, j)+values[i]*values[j]*values[k]) return res return dfs(0, len(values)-1) ","date":"2023-04-02","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%984.2/:0:1","tags":["Leetcode","小猪崽","动态规划","缓存装饰器"],"title":"[每日一题] 1039.多边形三角剖分的最低得分","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%984.2/"},{"categories":["狍噗噗带你玩转力扣！"],"content":"Leetcode","date":"2023-04-01","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%984.1/","tags":["Leetcode","小猪崽","字符串"],"title":"[每日一题] 831.隐藏个人信息","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%984.1/"},{"categories":["狍噗噗带你玩转力扣！"],"content":"Leetcode 每日一题 831.隐藏个人信息 每日一题 2023.04.01 题目描述： 给你一条个人信息字符串 s ，可能表示一个 邮箱地址 ，也可能表示一串 电话号码 。返回按如下规则 隐藏 个人信息后的结果： 电子邮件地址： 一个电子邮件地址由以下部分组成： 一个 名字 ，由大小写英文字母组成，后面跟着 一个 '@' 字符，后面跟着 一个 域名 ，由大小写英文字母和一个位于中间的 '.' 字符组成。'.' 不会是域名的第一个或者最后一个字符。 要想隐藏电子邮件地址中的个人信息： 名字 和 域名 部分的大写英文字母应当转换成小写英文字母。 名字 中间的字母（即，除第一个和最后一个字母外）必须用 5 个 \"*****\" 替换。 电话号码： 一个电话号码应当按下述格式组成： 电话号码可以由 10-13 位数字组成 后 10 位构成 本地号码 前面剩下的 0-3 位，构成 国家代码 利用 {'+', '-', '(', ')', ' '} 这些 分隔字符 按某种形式对上述数字进行分隔 要想隐藏电话号码中的个人信息： 移除所有 分隔字符 隐藏个人信息后的电话号码应该遵从这种格式： \"***-***-XXXX\"如果国家代码为 0 位数字 \"+*-***-***-XXXX\" 如果国家代码为 1 位数字 \"+**-***-***-XXXX\"如果国家代码为 2 位数字 \"+***-***-***-XXXX\"如果国家代码为 3 位数字 “XXXX” 是最后 4 位 本地号码 题目链接：831.隐藏个人信息 示例 1： 输入：s = \"LeetCode@LeetCode.com\" 输出：\"l*****e@leetcode.com\" 解释：s 是一个电子邮件地址。 名字和域名都转换为小写，名字的中间用 5 个 * 替换。 示例 2： 输入：s = \"AB@qq.com\" 输出：\"a*****b@qq.com\" 解释：s 是一个电子邮件地址。 名字和域名都转换为小写，名字的中间用 5 个 * 替换。 注意，尽管 \"ab\" 只有两个字符，但中间仍然必须有 5 个 * 。 示例 3： 输入：s = \"1(234)567-890\" 输出：\"***-***-7890\" 解释：s 是一个电话号码。 共计 10 位数字，所以本地号码为 10 位数字，国家代码为 0 位数字。 因此，隐藏后的电话号码应该是 \"***-***-7890\" 。 示例 4： 输入：s = \"86-(10)12345678\" 输出：\"+**-***-***-5678\" 解释：s 是一个电话号码。 共计 12 位数字，所以本地号码为 10 位数字，国家代码为 2 位数字。 因此，隐藏后的电话号码应该是 \"+**-***-***-7890\" 。 题目难度： 中等 题目解读： 本题主要是所用语言字符串处理常用函数 如s.lower() s.upper()可对字符串所有字符进行大小写判断 如s.index()可以返回指定字符在字符串中的位置下标 如ch.isdigit()可以对字符是否为0或正整数进行判读 ","date":"2023-04-01","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%984.1/:0:0","tags":["Leetcode","小猪崽","字符串"],"title":"[每日一题] 831.隐藏个人信息","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%984.1/"},{"categories":["狍噗噗带你玩转力扣！"],"content":"代码实现 class Solution: def maskPII(self, s: str) -\u003e str: res = \"\" # 邮件 if '@' in s: index1 = s.index('@') index2 = s.index('.') s = s.lower() res += s[0] res += '*' * 5 res += s[index1-1] res += '@' res += s[index1+1: index2] res += '.' res += s[index2+1:] return res # 手机号 else: cnt = 0 t = \"\" for ch in s: if ch.isdigit(): t += ch cnt += 1 if cnt == 10: res = \"***-***-\" res += t[-4:] elif cnt == 11: res = \"+*-***-***-\" res += t[-4:] elif cnt == 12: res = \"+**-***-***-\" res += t[-4:] elif cnt == 13: res = \"+***-***-***-\" res += t[-4:] return res ","date":"2023-04-01","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%984.1/:0:1","tags":["Leetcode","小猪崽","字符串"],"title":"[每日一题] 831.隐藏个人信息","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%984.1/"},{"categories":["狍噗噗带你玩转力扣！"],"content":"Leetcode","date":"2023-03-31","objectID":"/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%973.31/","tags":["Leetcode","小猪崽","哈希表","字符串","数学"],"title":"[学习日记] 罗马数字换换换","uri":"/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%973.31/"},{"categories":["狍噗噗带你玩转力扣！"],"content":"罗马数字和整数之间的转换练习 12.整数转罗马数字 13.罗马数字转整数 [学习日记] 罗马数字换换换 ","date":"2023-03-31","objectID":"/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%973.31/:0:0","tags":["Leetcode","小猪崽","哈希表","字符串","数学"],"title":"[学习日记] 罗马数字换换换","uri":"/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%973.31/"},{"categories":["狍噗噗带你玩转力扣！"],"content":"整数转罗马数字 题目描述： 罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给你一个整数，将其转为罗马数字。 题目链接： 12.整数转罗马数字 示例 1: 输入: num = 3 输出: \"III\" 示例 2: 输入: num = 4 输出: \"IV\" 示例 3: 输入: num = 9 输出: \"IX\" 示例 4: 输入: num = 58 输出: \"LVIII\" 解释: L = 50, V = 5, III = 3. 示例 5: 输入: num = 1994 输出: \"MCMXCIV\" 解释: M = 1000, CM = 900, XC = 90, IV = 4. 题目难度： 中等 题目解读： 罗马数字的表示方法是以规定的七种字符分别赋予不同数值，按其个数表示不同数值 实际上就是将一个阿拉伯数字按照七个字符搭配方式进行拆分或者说整除 比如说示例5中，num = 1994，1994可以拆分为1000(M)+900(CM)+90(XC)+4(IV)， M = 1000, CM = 900, XC = 90, IV = 4 整数转换为罗马数字，即是由大到小分别整除不同的字符组合，得出各组合数量，拼凑一起即可 而对应字符组合可用哈希表进行存储，将目标整数依次整除对应键值，即可获得相应字符组成的罗马数字 ","date":"2023-03-31","objectID":"/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%973.31/:1:0","tags":["Leetcode","小猪崽","哈希表","字符串","数学"],"title":"[学习日记] 罗马数字换换换","uri":"/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%973.31/"},{"categories":["狍噗噗带你玩转力扣！"],"content":"代码实现 class Solution: def intToRoman(self, num: int) -\u003e str: res = '' hashmap = {1000:'M', 900:'CM', 500:'D', 400:'CD', 100:'C', 90:'XC', 50:'L', 40:'XL', 10:'X', 9:'IX', 5:'V', 4:'IV', 1:'I'} for key in hashmap: if num // key != 0: count = num // key res += count * hashmap[key] num = num % key return res ","date":"2023-03-31","objectID":"/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%973.31/:1:1","tags":["Leetcode","小猪崽","哈希表","字符串","数学"],"title":"[学习日记] 罗马数字换换换","uri":"/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%973.31/"},{"categories":["狍噗噗带你玩转力扣！"],"content":"罗马数字转整数 题目描述： 罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个罗马数字，将其转换成整数。 题目链接： 13.罗马数字转整数 示例 1: 输入: s = \"III\" 输出: 3 示例 2: 输入: s = \"IV\" 输出: 4 示例 3: 输入: s = \"IX\" 输出: 9 示例 4: 输入: s = \"LVIII\" 输出: 58 解释: L = 50, V= 5, III = 3. 示例 5: 输入: s = \"MCMXCIV\" 输出: 1994 解释: M = 1000, CM = 900, XC = 90, IV = 4. 题目难度： 简单 题目解读： 相较于整型转换为罗马数字，需要按照从大到小对应的字符进行整除，罗马数字转换为整型，难度要小上一些 主要目标是正确读取各个字符，将其对应数值相加即可，而难点即是如何区分如CM，是读入为100+1000还是900 这里可以左右相邻字符大小关系作为判断关系，如C小于M,若C出现在M左侧，即是M减去C的含义 或者如本文所用方法一样，读取字符时，先读取两个连续两个字符，即i和i+1，优先匹配两个字符所表示的数值 ","date":"2023-03-31","objectID":"/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%973.31/:2:0","tags":["Leetcode","小猪崽","哈希表","字符串","数学"],"title":"[学习日记] 罗马数字换换换","uri":"/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%973.31/"},{"categories":["狍噗噗带你玩转力扣！"],"content":"代码实现 class Solution: def romanToInt(self, s: str) -\u003e int: res = 0 hashmap = { 'M' : 1000, 'CM': 900, 'D' : 500, 'CD': 400, 'C' : 100, 'XC': 90, 'L' : 50, 'XL': 40, 'X' : 10, 'IX': 9, 'V' : 5, 'IV': 4, 'I' : 1 } i = 0 while i \u003c len(s): if s[i: i+2] in hashmap: res += hashmap[s[i: i+2]] i += 2 else: res += hashmap[s[i]] i += 1 return res ","date":"2023-03-31","objectID":"/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%973.31/:2:1","tags":["Leetcode","小猪崽","哈希表","字符串","数学"],"title":"[学习日记] 罗马数字换换换","uri":"/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%973.31/"},{"categories":["狍噗噗带你玩转力扣！"],"content":"学习感悟 罗马数字和阿拉伯整数之间的一个转换，主要难点就是正确理解转换关系，再进而对由两个字符的组合映射关系进行合理判断。 具体代码实现，可以借助哈希表进行存储，进而解决整除或读取的映射问题。 ","date":"2023-03-31","objectID":"/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%973.31/:3:0","tags":["Leetcode","小猪崽","哈希表","字符串","数学"],"title":"[学习日记] 罗马数字换换换","uri":"/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%973.31/"},{"categories":["狍噗噗带你玩转力扣！"],"content":"Leetcode","date":"2023-03-31","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983.31/","tags":["Leetcode","小猪崽","哈希表","数组"],"title":"[每日一题] 2367.算术三元组的数目","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983.31/"},{"categories":["狍噗噗带你玩转力扣！"],"content":"Leetcode 每日一题 2367.算术三元组的数目 每日一题 2023.03.31 题目描述： 给你一个下标从 0 开始、严格递增 的整数数组 nums 和一个正整数 diff 。 如果满足下述全部条件，则三元组 (i, j, k) 就是一个 算术三元组 ： i \u003c j \u003c k ， nums[j] - nums[i] == diff nums[k] - nums[j] == diff 返回不同 算术三元组 的数目。 题目链接：2367.算术三元组的数目 示例 1： 输入：nums = [0,1,4,6,7,10], diff = 3 输出：2 解释： (1, 2, 4) 是算术三元组：7 - 4 == 3 且 4 - 1 == 3 。 (2, 4, 5) 是算术三元组：10 - 7 == 3 且 7 - 4 == 3 。 示例 2： 输入：nums = [4,5,6,7,8,9], diff = 2 输出：2 解释： (0, 2, 4) 是算术三元组：8 - 6 == 2 且 6 - 4 == 2 。 (1, 3, 5) 是算术三元组：9 - 7 == 2 且 7 - 5 == 2 。 题目难度： 简单 题目解读： 因为本题为严格递增数组，不存在重复元素，故只需要遍历一遍数组，寻找该列表中是否有该元素对应的后两个等差数即可 即对nums中各个元素n，判断是否存在n+diff和n+2*diff，如有则计数res加1 ","date":"2023-03-31","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983.31/:0:0","tags":["Leetcode","小猪崽","哈希表","数组"],"title":"[每日一题] 2367.算术三元组的数目","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983.31/"},{"categories":["狍噗噗带你玩转力扣！"],"content":"代码实现 class Solution: def arithmeticTriplets(self, nums: List[int], diff: int) -\u003e int: res = 0 for n in nums: if n+diff in nums and n+diff+diff in nums: res += 1 return res ","date":"2023-03-31","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983.31/:0:1","tags":["Leetcode","小猪崽","哈希表","数组"],"title":"[每日一题] 2367.算术三元组的数目","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983.31/"},{"categories":["狍噗噗带你玩转力扣！"],"content":"Leetcode","date":"2023-03-30","objectID":"/%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B03.30/","tags":["Leetcode","小猪崽","滑动窗口","双指针","回文数"],"title":"快来跟小猪崽一起做题叭！","uri":"/%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B03.30/"},{"categories":["狍噗噗带你玩转力扣！"],"content":"小猪崽来做题啦！ 904.水果成篮——滑动窗口 11.盛最多水的容器——双指针 9.回文数——数字翻转 904. 水果成篮 题目描述： 你正在探访一家农场，农场从左到右种植了一排果树。 这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果种类 。 你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果： 你只有 两个 篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。 你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。 采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。 一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。 给你一个整数数组 fruits，返回你可以收集的水果的 最大 数目。 题目链接： 904. 水果成篮 - 力扣（LeetCode） 注意： 对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。 如果 s 中存在这样的子串，我们保证它是唯一的答案。 题目难度： 中等 示例 1： 输入：fruits = [1,2,1] 输出：3 解释：可以采摘全部 3 棵树。 示例 2： 输入：fruits = [0,1,2,2] 输出：3 解释：可以采摘 [1,2,2] 这三棵树。 如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。 示例 3： 输入：fruits = [1,2,3,2,2] 输出：4 解释：可以采摘 [2,3,2,2] 这四棵树。 如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。 示例 4： 输入：fruits = [3,3,3,1,2,1,1,2,3,3,4] 输出：5 解释：可以采摘 [1,2,1,1,2] 这五棵树。 参考链接： 代码随想录 (programmercarl.com) ","date":"2023-03-30","objectID":"/%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B03.30/:0:0","tags":["Leetcode","小猪崽","滑动窗口","双指针","回文数"],"title":"快来跟小猪崽一起做题叭！","uri":"/%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B03.30/"},{"categories":["狍噗噗带你玩转力扣！"],"content":"思路分析 滑动窗口的思想，以终止指针为循环遍历索引，依据水果种类数量是否达到上限作为数据更新依据 当子序列中水果种类小于2时，直接采摘当前水果； 当子序列中水果种类等于2时，如果已有当前水果种类，继续采摘； 如果没有，记录此时水果数量，左边界进行收缩，起始指针右移，直至水果种类数量减少 ","date":"2023-03-30","objectID":"/%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B03.30/:0:1","tags":["Leetcode","小猪崽","滑动窗口","双指针","回文数"],"title":"快来跟小猪崽一起做题叭！","uri":"/%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B03.30/"},{"categories":["狍噗噗带你玩转力扣！"],"content":"代码实现 class Solution: def totalFruit(self, fruits: List[int]) -\u003e int: i = 0 res = 0 classCnt = 0 fruitClass = {} for j in range(len(fruits)): if fruits[j] in fruitClass.keys(): fruitClass[fruits[j]] += 1 elif classCnt \u003c 2: fruitClass[fruits[j]] = 1 classCnt += 1 else: res = max(res, j-i) while classCnt == 2: fruitClass[fruits[i]] -= 1 if fruitClass[fruits[i]] == 0: del fruitClass[fruits[i]] classCnt -= 1 i += 1 fruitClass[fruits[j]] = 1 classCnt += 1 return max(res, j-i+1) ","date":"2023-03-30","objectID":"/%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B03.30/:0:2","tags":["Leetcode","小猪崽","滑动窗口","双指针","回文数"],"title":"快来跟小猪崽一起做题叭！","uri":"/%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B03.30/"},{"categories":["狍噗噗带你玩转力扣！"],"content":"本题知识点 Counter() 函数 类似于此前接触到的collecions.defaultdict(int)，可对字典进行整型默认赋值，还可以将list中各元素按照计次进行排序 滑动窗口进行起始指针更新时，常用while循环进行收缩 不考虑优化的情况下，可以在每一次循环最后，进行一次结果res的更新 11. 盛最多水的容器 题目描述： 给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。 找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 返回容器可以储存的最大水量。 说明：你不能倾斜容器。 题目链接： 11. 盛最多水的容器 - 力扣（LeetCode） 题目难度： 中等 示例 1： 输入：[1,8,6,2,5,4,8,3,7] 输出：49 解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 示例 2： 输入：height = [1,1] 输出：1。 ","date":"2023-03-30","objectID":"/%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B03.30/:0:3","tags":["Leetcode","小猪崽","滑动窗口","双指针","回文数"],"title":"快来跟小猪崽一起做题叭！","uri":"/%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B03.30/"},{"categories":["狍噗噗带你玩转力扣！"],"content":"思路分析 相较于暴力求解每种可能，在左、右边界设置双指针，进行剪枝排除不可能的情况更优 解题的核心思想即是在每个状态下，无论长板或短板向中间收窄一格，都会导致水槽 底边宽度 变短： 若向内移动短板 ，水槽的短板min(h[i],h[j]) 可能变大，因此下个水槽的面积可能增大。 若向内移动长板 ，水槽的短板min(h[i],h[j])​ 不变或变小，因此下个水槽的面积一定变小。 因此，初始化双指针分列水槽左右两端，循环每轮将短板向内移动一格，并更新面积最大值，直到两指针相遇时跳出；即可获得最大面积。 参考链接： https://leetcode.cn/problems/container-with-most-water/solution/container-with-most-water-shuang-zhi-zhen-fa-yi-do/ ","date":"2023-03-30","objectID":"/%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B03.30/:0:4","tags":["Leetcode","小猪崽","滑动窗口","双指针","回文数"],"title":"快来跟小猪崽一起做题叭！","uri":"/%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B03.30/"},{"categories":["狍噗噗带你玩转力扣！"],"content":"代码实现 class Solution: def maxArea(self, height: List[int]) -\u003e int: i = 0 j = len(height)-1 res = 0 while i \u003c j: if height[i] \u003c= height[j]: res = max(res, height[i]*(j-i)) i += 1 else: res = max(res, height[j]*(j-i)) j -= 1 return res ","date":"2023-03-30","objectID":"/%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B03.30/:0:5","tags":["Leetcode","小猪崽","滑动窗口","双指针","回文数"],"title":"快来跟小猪崽一起做题叭！","uri":"/%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B03.30/"},{"categories":["狍噗噗带你玩转力扣！"],"content":"本题知识点 双指针置于左右边界 向内收缩 与 将包含正负数的有序数组的各元素的平方进行排序 异曲同工 9. 回文数 题目描述： 给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。 回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 例如，121 是回文，而 123 不是。 题目链接： 9. 回文数 - 力扣（LeetCode） 题目难度： 简单 示例 1： 输入：x = 121 输出：true 示例 2： 输入：x = -121 输出：false 解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例 3： 输入：x = 10 输出：false 解释：从右向左读, 为 01 。因此它不是一个回文数。 ","date":"2023-03-30","objectID":"/%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B03.30/:0:6","tags":["Leetcode","小猪崽","滑动窗口","双指针","回文数"],"title":"快来跟小猪崽一起做题叭！","uri":"/%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B03.30/"},{"categories":["狍噗噗带你玩转力扣！"],"content":"思路分析 如果没有限制，直接将整形转换为字符串，字符串转换列表，列表翻转，相同即为回文数。 ","date":"2023-03-30","objectID":"/%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B03.30/:0:7","tags":["Leetcode","小猪崽","滑动窗口","双指针","回文数"],"title":"快来跟小猪崽一起做题叭！","uri":"/%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B03.30/"},{"categories":["狍噗噗带你玩转力扣！"],"content":"代码实现 class Solution: def isPalindrome(self, x: int) -\u003e bool: if x \u003c 0: return False else: s = str(x) l = list(s) t = [] for e in l: t.append(e) l.reverse() if t == l: return True else: return False ","date":"2023-03-30","objectID":"/%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B03.30/:0:8","tags":["Leetcode","小猪崽","滑动窗口","双指针","回文数"],"title":"快来跟小猪崽一起做题叭！","uri":"/%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B03.30/"},{"categories":["狍噗噗带你玩转力扣！"],"content":"进阶限制 如果考虑限制，不可以将整型转为字符串，则考虑数学方法进行各数位提取，考虑到优化和部分语言溢出的可能，只需翻转一半即可 如何判断是否已经翻转一半，可以依据剩余数字是否小于已翻转数字 考虑到回文数数字个数奇偶性，在最后结果的判定上，考虑奇数个数位的情况 **参考链接：**https://leetcode.cn/problems/palindrome-number/solution/dong-hua-hui-wen-shu-de-san-chong-jie-fa-fa-jie-ch/ ","date":"2023-03-30","objectID":"/%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B03.30/:0:9","tags":["Leetcode","小猪崽","滑动窗口","双指针","回文数"],"title":"快来跟小猪崽一起做题叭！","uri":"/%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B03.30/"},{"categories":["狍噗噗带你玩转力扣！"],"content":"代码实现 class Solution: def isPalindrome(self, x: int) -\u003e bool: if (x \u003c 0 or (x % 10 == 0 and x != 0)): return False revertedNumber = 0 while (x \u003e revertedNumber): revertedNumber = revertedNumber * 10 + x % 10 x = x // 10 return x == revertedNumber or x == revertedNumber // 10; ","date":"2023-03-30","objectID":"/%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B03.30/:0:10","tags":["Leetcode","小猪崽","滑动窗口","双指针","回文数"],"title":"快来跟小猪崽一起做题叭！","uri":"/%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B03.30/"},{"categories":["狍噗噗带你玩转力扣！"],"content":"本题知识点 数字对10求模，是提取整型各数位数字的常用方法 依据剩余数字是否小于已翻转数字，很巧妙的判断方法！ 最后考虑到回文数字的奇偶性，对返回结果进行补充判断 ","date":"2023-03-30","objectID":"/%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B03.30/:0:11","tags":["Leetcode","小猪崽","滑动窗口","双指针","回文数"],"title":"快来跟小猪崽一起做题叭！","uri":"/%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B03.30/"},{"categories":["狍噗噗带你玩转力扣！"],"content":"Leetcode","date":"2023-03-30","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983.30/","tags":["Leetcode","狍噗噗","排序","数组"],"title":"狍噗噗的第二篇文章！","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983.30/"},{"categories":["狍噗噗带你玩转力扣！"],"content":"Leetcode 每日一题 1637.两点之间不包含任何点的最宽垂直区域 每日一题 2023.03.30 题目描述： 给你 n 个二维平面上的点 points ，其中 points[i] = [xi, yi] ，请你返回两点之间内部不包含任何点的 最宽垂直区域 的宽度。 垂直区域 的定义是固定宽度，而 y 轴上无限延伸的一块区域（也就是高度为无穷大）。 最宽垂直区域 为宽度最大的一个垂直区域。 请注意，垂直区域 边上 的点 不在 区域内。 题目链接：1637.两点之间不包含任何点的最宽垂直区域 示例 1： 输入：points = [[8,7],[9,9],[7,4],[9,7]] 输出：1 解释：红色区域和蓝色区域都是最优区域。 示例 2： 输入：points = [[3,1],[9,0],[1,0],[1,4],[5,3],[8,8]] 输出：3 题目难度： 中等 题目解读： 给定n个二维平面上的点，求两点之间内部不包含任何点的最宽垂直区域的宽度。 主要注意二维vector的一些操作 ","date":"2023-03-30","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983.30/:0:0","tags":["Leetcode","狍噗噗","排序","数组"],"title":"狍噗噗的第二篇文章！","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983.30/"},{"categories":["狍噗噗带你玩转力扣！"],"content":"代码实现 1.定义二维vector： vector\u003cvector\u003cint\u003e\u003e A; 相当于是四个长度为2的vector组成了vector A； 2.二维vector的插入： vector\u003cvector\u003cint\u003e\u003e A; vector\u003cint\u003e B;//A.push_back的对象必须是vector B.push_back(0); B.push_back(1); A.push_back(B);//!! B.clear();//清空vector B里面的内容 B.push_back(3); B.push_back(4); B.push_back(5); A.push_back(B);//由此可得A=[[0,1],[3,4,5]]; 3.vector长度的获取 以2中得到的A为例： int len1=A.size();//代表A中vector的个数 int len2=A[0].size();//代表A中第0个vector元素的长度 int len3=A[1].size(); //=\u003elen1=2; // len2=2; // len3=3; 4.sort排序 ①默认按vector的第一个关键字升序排列，第一个关键字相同的，按第二个关键字升序排列： //A=[[8,7],[9,9],[7,4],[9,7]] sort(A.begin(),A.end()); //A=[[7,4],[8,7],[9,7],[9,9]] ②按vector的第一个关键字升序排列，第二个关键字降序排列： //A=[[8,7],[9,9],[7,4],[9,7]] //Lambda表达式 sort(A.begin(),A.end(),[](vector\u003cint\u003e\u0026 a, vector\u003cint\u003e\u0026 b) { return a[0] == b[0] ? a[1] \u003e b[1]:a[0] \u003c b[0]; }); //A==[[7,4],[8,7],[9,9],[9,7]] ③按vector的第二个关键字（每个子vector的第二个元素）降序排列： //A=[[8,7],[9,9],[7,4],[9,7]] sort(A.begin(),A.end(),[](vector\u003cint\u003e\u0026 a, vector\u003cint\u003e\u0026 b) { return a[1] \u003e b[1]; }); //A=[[9,9],[8,7],[9,7],[7,4]] ","date":"2023-03-30","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983.30/:0:1","tags":["Leetcode","狍噗噗","排序","数组"],"title":"狍噗噗的第二篇文章！","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983.30/"},{"categories":["狍噗噗带你玩转力扣！"],"content":"算法逻辑 1.将坐标点按x轴坐标从小到大排序； 2.按序排列的x坐标两两求差，最大的差值对应于最宽垂直区域的宽度。 class Solution { public: int maxWidthOfVerticalArea(vector\u003cvector\u003cint\u003e\u003e\u0026 points) { sort(points.begin(),points.end()); int res=0; int dif=0; for(int i=1;i\u003cpoints.size();i++) { dif=points[i][0]-points[i-1][0]; res=max(res,dif); } return res; } }; ","date":"2023-03-30","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983.30/:0:2","tags":["Leetcode","狍噗噗","排序","数组"],"title":"狍噗噗的第二篇文章！","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983.30/"},{"categories":["狍噗噗带你玩转力扣！"],"content":"Leetcode","date":"2023-03-30","objectID":"/%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B03.29/","tags":["Leetcode","小猪崽","滑动窗口"],"title":"小猪崽和你一起练习滑动窗口！","uri":"/%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B03.29/"},{"categories":["狍噗噗带你玩转力扣！"],"content":"小猪崽来做题啦！ 76.最小覆盖子串 小猪崽学习滑动窗口之后做的第一道练习 题目描述： 给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。 如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串\"\" 题目链接： 76. 最小覆盖子串 - 力扣（LeetCode） 注意： 对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。 如果 s 中存在这样的子串，我们保证它是唯一的答案。 题目难度： 困难 示例 1： 输入：s = \"ADOBECODEBANC\", t = \"ABC\"\r输出：\"BANC\"\r解释：最小覆盖子串 \"BANC\" 包含来自字符串 t 的 'A'、'B' 和 'C'。\r示例 2： 输入：s = \"a\", t = \"a\"\r输出：\"a\"\r解释：整个字符串 s 是最小覆盖子串。\r示例 3: 输入: s = \"a\", t = \"aa\"\r输出: \"\"\r解释: t 中两个字符 'a' 均应包含在 s 的子串中，\r因此没有符合条件的子字符串，返回空字符串。\r","date":"2023-03-30","objectID":"/%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B03.29/:0:0","tags":["Leetcode","小猪崽","滑动窗口"],"title":"小猪崽和你一起练习滑动窗口！","uri":"/%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B03.29/"},{"categories":["狍噗噗带你玩转力扣！"],"content":"第一次尝试: 参考链接： 代码随想录 (programmercarl.com) 因为是有备而来的转向练习，上来就找到了大方向——滑动窗口！ 滑动窗口常用双指针i，j作为序列的头尾下标，以尾标作为循环的索引。 循环遍历是滑动窗口不错了，但循环过程中对子序列采取一个check函数进行检测，不断复制字典简直太笨笨啦！ 完全就是脱裤子放屁，套娃套迷糊了！代码逻辑问题不大，可以跑通，但是遇上大篇幅字符串直接超时。 class Solution: def minWindow(self, s: str, t: str) -\u003e str: s_len = len(s) t_len = len(t) if s_len \u003c t_len: return \"\" d = {} for i in t: # 初始化 if d.get(i): d[i] += 1 else: d[i] = 1 def check(s: str): dic_t = d.copy() count = 0 for j in s: if j in dic_t: if dic_t[j] \u003c 1: continue else: dic_t[j] -= 1 for k in dic_t.keys(): count += dic_t[k] if count == 0: return True else: return False l = 0 r = 0 l_min = -1 r_min = -1 min_len = float(\"inf\") for r in range(s_len): # print(l, r) while check(s[l: r+1]): # print(s[l: r+1], t) # print(check(s[l: r+1], t)) len_temp = r - l + 1 if len_temp \u003c min_len: min_len = len_temp l_min, r_min = l, r # print(min_len) l += 1 return \"\" if l_min == -1 else s[l_min: r_min+1] ","date":"2023-03-30","objectID":"/%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B03.29/:0:1","tags":["Leetcode","小猪崽","滑动窗口"],"title":"小猪崽和你一起练习滑动窗口！","uri":"/%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B03.29/"},{"categories":["狍噗噗带你玩转力扣！"],"content":"第二次尝试: 经过优化，将字典改为全局的哈希表，用于记录t中各个字符出现的次数 先将终止位置往后延申，当子序列满足需求后，再收缩起始位置，循环往复至遍历结束 滑动窗口常以初始化双指针坐标起手，之后在循环中不断后移起始坐标，关键点在于双指针发生移动的判断逻辑 class Solution: def minWindow(self, s: str, t: str) -\u003e str: needcnt = len(t) need = collections.defaultdict(int) for ch in t: need[ch] += 1 i = 0 j = 0 ans = float(\"inf\") res_l = 0 res_r = 0 # print(need) for j, ch in enumerate(s): # 如果是t中字符 如果用.get() 当值为0 语句是判断为不执行的！ if ch in need.keys(): # 如果该字符还有需求 if need[ch] \u003e 0: need[ch] -= 1 needcnt -= 1 # 如果该字符没有需求 else: need[ch] -= 1 # t中字符均已满足 while needcnt == 0: # 如果最左字符是t中字符 if s[i] in need.keys(): # 如果需求小于0 即有富余 if need[s[i]] \u003c 0: need[s[i]] += 1 i += 1 # 如果没有富余 else: l = j - i + 1 if l \u003c ans: ans = l res_l = i res_r = j need[s[i]] += 1 needcnt += 1 i += 1 break else: i += 1 return '' if ans == float(\"inf\") else s[res_l: res_r+1] ","date":"2023-03-30","objectID":"/%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B03.29/:0:2","tags":["Leetcode","小猪崽","滑动窗口"],"title":"小猪崽和你一起练习滑动窗口！","uri":"/%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B03.29/"},{"categories":["狍噗噗带你玩转力扣！"],"content":"本题踩坑点： 没必要用函数来循环检验，这样只是遍历的时候用了滑动窗口的思想，还是会超时，应直接改用全局哈希表存储各字符需求次数 用dict.get()时，如果值为0，则判断语句会判断为False，而我们的需求实则是字典中存在这个key即可 最后结果是要输出最短的字符串，而非长度，还需保存一下左右下标，可以用res = (0, float('inf')) 数组来存储，后续下标即为res[0] res[1] 本题没踩坑，但顺带提醒一下，字符串s[i: j+1] 右边的参数得为j+1 才能取到 i 到 j 本题用到的一些常见语法，如collections.defaultdict(int)对字典进行整型默认赋值，enumerate()枚举函数，和字典的dict.keys()以及dict.get() ","date":"2023-03-30","objectID":"/%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B03.29/:0:3","tags":["Leetcode","小猪崽","滑动窗口"],"title":"小猪崽和你一起练习滑动窗口！","uri":"/%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B03.29/"},{"categories":["狍噗噗带你玩转力扣！"],"content":"Leetcode","date":"2023-03-29","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983.29/","tags":["Leetcode","狍噗噗","小猪崽","动态规划","排列组合"],"title":"小猪崽的第一篇文章！","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983.29/"},{"categories":["狍噗噗带你玩转力扣！"],"content":"Leetcode 每日一题 1641.统计字典序元音字符串的数目 每日一题 2023.03.29 题目描述： 给你一个整数 n，请返回长度为 n 、仅由元音 (a, e, i, o, u) 组成且按 字典序排列 的字符串数量。 字符串 s 按 字典序排列 需要满足：对于所有有效的 i，s[i] 在字母表中的位置总是与s[i+1]相同或在s[i+1]之前。 题目链接：1641. 统计字典序元音字符串的数目 示例 1： 输入：n = 1 输出：5 解释：仅由元音组成的 5 个字典序字符串为 [\"a\",\"e\",\"i\",\"o\",\"u\"] 示例 2： 输入：n = 2 输出：15 解释：仅由元音组成的 15 个字典序字符串为 [\"aa\",\"ae\",\"ai\",\"ao\",\"au\",\"ee\",\"ei\",\"eo\",\"eu\",\"ii\",\"io\",\"iu\",\"oo\",\"ou\",\"uu\"] 注意，\"ea\" 不是符合题意的字符串，因为 'e' 在字母表中的位置比 'a' 靠后 示例 3： 输入：n = 33 输出：66045 ","date":"2023-03-29","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983.29/:0:0","tags":["Leetcode","狍噗噗","小猪崽","动态规划","排列组合"],"title":"小猪崽的第一篇文章！","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983.29/"},{"categories":["狍噗噗带你玩转力扣！"],"content":"狍噗噗来带你做题目啦 题目解读： 排列组合问题，有五个有序字符（a\u003ee\u003ei\u003eo\u003eu），找其按顺序排列（后面一位只能小于等于前一位）能组成的长度为n的字符串个数。 我的解题思路：找规律 n=1时，res=1(a)+1(e)+1(i)+1(o)+1(u)=5； n=2时，res=5(a)+4(e)+3(i)+2(o)+1(u)=[(1+1+1+1+1)+(1+1+1+1)+(1+1+1)+(1+1)+1]=15; n=3时，res=15(a=a’+e’+i’+o’+u’)+10(e=e’+i’+o’+u’)+6(i=i’+o’+u’)+4(o=o’+u’)+1(u’)=35； n=4时，res=35+20+10+4+1=70; … 算法逻辑如下： 维护变量a，e，i，o，u，分别记录以a，e，i，o，u为开头的可能的字符串个数； 所求结果res=a+e+i+o+u; class Solution { public: int countVowelStrings(int n) { int a=1,e=1,i=1,o=1,u=1; int res=0; for(int j=1;j\u003cn;j++) { a=a+e+i+o+u; e=e+i+o+u; i=i+o+u; o=o+u; u=u; } res=a+e+i+o+u; return res; } }; ","date":"2023-03-29","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983.29/:1:0","tags":["Leetcode","狍噗噗","小猪崽","动态规划","排列组合"],"title":"小猪崽的第一篇文章！","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983.29/"},{"categories":["狍噗噗带你玩转力扣！"],"content":"小猪崽来学着做题目啦 ","date":"2023-03-29","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983.29/:2:0","tags":["Leetcode","狍噗噗","小猪崽","动态规划","排列组合"],"title":"小猪崽的第一篇文章！","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983.29/"},{"categories":["狍噗噗带你玩转力扣！"],"content":"方法1：动态规划 定义一个数组 dp[j] 表示以第j个字符结尾，可见当字符串长度为n = 1, 2, 3时，目标字符串结果分别如下： n a e i o u 1 1 1 1 1 1 2 1 2 3 4 5 3 1 3 6 10 15 可见当字符串长度为n时，目标字符串可在以第0-j个字符结尾，长度为n-1的字符串基础上，再添加一个该字符 比如当n = 2， j = 4时，即表示求解以u结尾，长度为2的字符串，即dp[4] = 1+1+1+1+1 不难看出dp[3] = 1+1+1+1，因此可进一步简化为 dp[4] = dp[3] + dp[4] 实际意义可以理解为上述在第0-j个字符结尾，长度为n-1的字符串基础上，再添加一个该字符，也可以理解为一部分情况是在第j个字符结尾，长度为n-1的字符串基础上，再添加一个该字符，另一部分是将以 第j-1个字符结尾，长度为n的字符串的最后一个字符，由原先的j-1变为j class Solution: def countVowelStrings(self, n: int) -\u003e int: # a, e, i, o, u dp = [1]*5 # dp[j] 以字符j结尾的个数 if n == 1: return 5 # 即在初始化n=1基础上，再计算n-1轮dp for i in range(1, n): for j in range(1, 5): dp[j] = dp[j] + dp[j-1] return sum(dp) 参考链接：图解版 秒懂（官方动态规划） - 统计字典序元音字符串的数目 - 力扣（LeetCode） ","date":"2023-03-29","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983.29/:2:1","tags":["Leetcode","狍噗噗","小猪崽","动态规划","排列组合"],"title":"小猪崽的第一篇文章！","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983.29/"},{"categories":["狍噗噗带你玩转力扣！"],"content":"方法2：数学组合 引用链接：中学数学科普：n 个小球放到 m 个盒子里 - 统计字典序元音字符串的数目 - 力扣（LeetCode） 这里直接摆上讲的很详细的题解： 可以把问题转换成将 n 个小球放到 5 个盒子里，盒子可以为空。 我们可以想象成把 n 个字符分配给五个元音所代表的盒子中。一旦每个盒子中的字符个数定了，那么这个字符串也固定下来了。因为题目要求必须是字典序，所以一定 a 字符在最前；其次是 e 字符；其次是 i 字符；其次是 o 字符；其次是 u 字符。 下面问题的关键就是，n 个小球放到 5 个盒子里，盒子可以为空，一共有多少种方法？ 这是经典的中学数学问题。更一般的，我们来探讨，将 n 个小球放到 m 个盒子里，有多少种方法？ 首先，我们考虑问题的简单版本，即盒子不能为空的情况。 此时，我们只需要在 n 个小球排成一排，中间放 m - 1 个隔板，放好以后，相当于把 n 个小球分成了 m 份。每一份对应一个盒子里的小球数量。 因为盒子不能为空，所以两个小球之间不可能放多个隔板，左右两端也不可能放隔板。因此，放隔板的位置有 n - 1 个，我们要放 m - 1 个隔板。答案为 C(n - 1, m - 1)。 有了这个结论，再来讨论问题的复杂版本，就简单了，即盒子可以为空的情况。 此时，我们只需要先拿 m 个新的小球，在 m 个盒子里，每个盒子中扔进去一个小球。之后，再分配原来的这 n 个小球，得到的分配结果，肯定 m 个盒子里都不为空。但此时，我们使用了 n + m 个小球。 换句话说，把 n 个小球放到 m 个盒子里，盒子可以为空，等价于：把 n + m 个小球放到 m 个盒子里，盒子不能为空。 大家也可以想成是：我们先把 n + m 个小球放到 m 个盒子里，盒子不能为空，然后再在每个盒子里拿走 1 个小球，总共拿走了 m 个小球，得到的结果，就是把 n 个小球放到 m 个盒子里，盒子可以为空的解。 把 n + m 个小球放到 m 个盒子里，盒子不能为空的分法，带入上面的公式，就是 C(n + m - 1, m - 1) 所以，把 n 个小球放到 m 个盒子里，盒子可以为空，答案为 C(n + m - 1, m - 1)。 总结： 将 n 个小球放到 m 个盒子里，盒子不为空：C(n - 1, m - 1)； 将 n 个小球放到 m 个盒子里，盒子可以空：C(n + m - 1, m - 1)； 对于这个问题，m = 5，盒子可以为空，所以答案是 C(n + 5 - 1, 5 - 1) = C(n + 4, 4) class Solution: def countVowelStrings(self, n: int) -\u003e int: return (n + 4) * (n + 3) * (n + 2) * (n + 1) // 24 ","date":"2023-03-29","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983.29/:2:2","tags":["Leetcode","狍噗噗","小猪崽","动态规划","排列组合"],"title":"小猪崽的第一篇文章！","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983.29/"},{"categories":["狍噗噗带你玩转力扣！"],"content":"Leetcode","date":"2023-03-27","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983.27/","tags":["Leetcode","狍噗噗"],"title":"狍噗噗的第一篇文章！","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983.27/"},{"categories":["狍噗噗带你玩转力扣！"],"content":"Leetcode 每日一题 1638.统计只差一个字符的子串数目 每日一题2023.03.27 题目解读：给定字符串s和t，寻找s与t两串中只有一个字符不同的子字符串对的数目。 子字符串的长度应相同 子字符串对只能有一个字符不同 不同字符在两个子字符串中的位置相同 注意s=abcde，t=abfde中，{bc,bf}、{cd,fd}、{bcd,bfd}都是满足条件的子字符串对 算法逻辑如下： 按从左到右的顺序，以i、j分别作为s、t子串的起始坐标； 如果s[i]$\\neq$t[j]，首先可以作为长度为1的子字符串成为满足要求的一对子字符串，如果下一位相同，获得另一对子字符串，依次类推，直到读到下一位不同的字符终止； 如果s[i]$=$t[j]，就是左边有相同子字符串的情况，那就向右读取字符，寻找只有一位字符不一样子字符串。 相当于都向右读在这一过程中只能有一位字符不一样的子字符串对会被接收，所以用一个局部变量dif计数子字符串对中同一位置字符不同的个数，dif=1的字符串对都能被接收，用全局变量cnt作为计数器。 class Solution { public: int countSubstrings(string s, string t) { if(s.empty()||t.empty()) return 0; int cnt=0; for(int i=0;i\u003cs.length();i++) { for(int j=0;j\u003ct.length();j++) { int tmp=0; int dif=0; while((i+tmp\u003cs.length())\u0026\u0026(j+tmp\u003ct.length())) { if(s[i+tmp]!=t[j+tmp]) ++dif; if(dif==1) cnt++; if(dif\u003e1) break; ++tmp; } } } return cnt; } }; ","date":"2023-03-27","objectID":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983.27/:0:0","tags":["Leetcode","狍噗噗"],"title":"狍噗噗的第一篇文章！","uri":"/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983.27/"}]