---
title: "小猪崽的第一篇文章！"
subtitle: "Leetcode 每日一题"
date: 2023-03-29T18:08:00+08:00
lastmod: 2023-03-29T18:08:00+08:00
author: "今天作者是小猪崽"
authorLink: "https://github.com/weijiesun1007"
description: "Leetcode"
tags: 
    - Leetcode  
    - 狍噗噗
    - 小猪崽
    - 动态规划
    - 排列组合

categories: 
    - 狍噗噗带你玩转力扣！
---

# 每日一题 2023.03.29

**题目描述：**

给你一个整数 n，请返回长度为 `n` 、仅由元音 `(a, e, i, o, u) `组成且按 字典序排列 的字符串数量。

字符串` s` 按 字典序排列 需要满足：对于所有有效的` i，s[i]` 在字母表中的位置总是与` s[i+1] `相同或在` s[i+1] `之前。

**题目链接：**[1641. 统计字典序元音字符串的数目](https://leetcode.cn/problems/count-sorted-vowel-strings/)

示例 1：

```
输入：n = 1
输出：5
解释：仅由元音组成的 5 个字典序字符串为 ["a","e","i","o","u"]
```

示例 2：

```
输入：n = 2
输出：15
解释：仅由元音组成的 15 个字典序字符串为
["aa","ae","ai","ao","au","ee","ei","eo","eu","ii","io","iu","oo","ou","uu"]
注意，"ea" 不是符合题意的字符串，因为 'e' 在字母表中的位置比 'a' 靠后
```

示例 3：

```
输入：n = 33
输出：66045
```

## 狍噗噗来带你做题目啦

**题目解读：**
排列组合问题，有五个有序字符（a>e>i>o>u），找其按顺序排列（后面一位只能小于等于前一位）能组成的长度为n的字符串个数。

- 我的解题思路：找规律
- n=1时，res=1(a)+1(e)+1(i)+1(o)+1(u)=5；
- n=2时，res=5(a)+4(e)+3(i)+2(o)+1(u)=[(1+1+1+1+1)+(1+1+1+1)+(1+1+1)+(1+1)+1]=15;
- n=3时，res=15(a=a'+e'+i'+o'+u')+10(e=e'+i'+o'+u')+6(i=i'+o'+u')+4(o=o'+u')+1(u')=35；
- n=4时，res=35+20+10+4+1=70;
- ...
- 算法逻辑如下：
  1. 维护变量a，e，i，o，u，分别记录以a，e，i，o，u为开头的可能的字符串个数；
  2. 所求结果res=a+e+i+o+u;

```c++
class Solution {
public:
    int countVowelStrings(int n) {
        int a=1,e=1,i=1,o=1,u=1;
        int res=0;
        for(int j=1;j<n;j++)
        {
            a=a+e+i+o+u;
            e=e+i+o+u;
            i=i+o+u;
            o=o+u;
            u=u;
        }
        res=a+e+i+o+u;
        return res;
    }
};
```

## 小猪崽来学着做题目啦
### 方法1：动态规划

定义一个数组 `dp[j]` 表示以第`j`个字符结尾，可见当字符串长度为`n = 1, 2, 3`时，目标字符串结果分别如下：

|  n   |  a   |  e   |  i   |  o   |  u   |
| :--: | :--: | :--: | :--: | :--: | :--: |
|  1   |  1   |  1   |  1   |  1   |  1   |
|  2   |  1   |  2   |  3   |  4   |  5   |
|  3   |  1   |  3   |  6   |  10  |  15  |

可见当字符串长度为`n`时，目标字符串可在以第`0-j`个字符结尾，长度为`n-1`的字符串基础上，再添加一个该字符

比如当n = 2， j = 4时，即表示求解以u结尾，长度为2的字符串，即dp[4] = 1+1+1+1+1

不难看出dp[3] = 1+1+1+1，因此可进一步简化为 dp[4] = dp[3] + dp[4]

实际意义可以理解为上述在第`0-j`个字符结尾，长度为`n-1`的字符串基础上，再添加一个该字符，也可以理解为一部分情况是在第`j`个字符结尾，长度为`n-1`的字符串基础上，再添加一个该字符，另一部分是将以 第`j-1`个字符结尾，长度为`n`的字符串的最后一个字符，由原先的`j-1`变为`j`

```python
class Solution:
    def countVowelStrings(self, n: int) -> int:
        # a, e, i, o, u
        dp = [1]*5
        
        # dp[j] 以字符j结尾的个数
        if n == 1:
            return 5
		# 即在初始化n=1基础上，再计算n-1轮dp
        for i in range(1, n):
            for j in range(1, 5):
                dp[j] = dp[j] + dp[j-1]
        return sum(dp)
```

参考链接：[图解版 秒懂（官方动态规划） - 统计字典序元音字符串的数目 - 力扣（LeetCode）](https://leetcode.cn/problems/count-sorted-vowel-strings/solution/tu-jie-ban-miao-dong-guan-fang-dong-tai-a80fa/)



### 方法2：数学组合

引用链接：[中学数学科普：n 个小球放到 m 个盒子里 - 统计字典序元音字符串的数目 - 力扣（LeetCode）](https://leetcode.cn/problems/count-sorted-vowel-strings/solution/zhong-xue-shu-xue-ke-pu-n-ge-xiao-qiu-fang-dao-m-g/)

这里直接摆上讲的很详细的题解：

可以把问题转换成将 n 个小球放到 5 个盒子里，盒子可以为空。

我们可以想象成把 n 个字符分配给五个元音所代表的盒子中。一旦每个盒子中的字符个数定了，那么这个字符串也固定下来了。因为题目要求必须是字典序，所以一定 a 字符在最前；其次是 e 字符；其次是 i 字符；其次是 o 字符；其次是 u 字符。

下面问题的关键就是，n 个小球放到 5 个盒子里，盒子可以为空，一共有多少种方法？

这是经典的中学数学问题。更一般的，我们来探讨，将 n 个小球放到 m 个盒子里，有多少种方法？



首先，我们考虑问题的简单版本，即**盒子不能为空**的情况。

此时，我们只需要在 n 个小球排成一排，中间放 m - 1 个隔板，放好以后，相当于把 n 个小球分成了 m 份。每一份对应一个盒子里的小球数量。

因为盒子不能为空，所以两个小球之间不可能放多个隔板，左右两端也不可能放隔板。因此，放隔板的位置有 n - 1 个，我们要放 m - 1 个隔板。答案为 C(n - 1, m - 1)。

有了这个结论，再来讨论问题的复杂版本，就简单了，即**盒子可以为空**的情况。

此时，我们只需要先拿 m 个新的小球，在 m 个盒子里，每个盒子中扔进去一个小球。之后，再分配原来的这 n 个小球，得到的分配结果，肯定 m 个盒子里都不为空。但此时，我们使用了 n + m 个小球。

换句话说，把 n 个小球放到 m 个盒子里，盒子可以为空，等价于：把 n + m 个小球放到 m 个盒子里，盒子不能为空。

大家也可以想成是：我们先把 n + m 个小球放到 m 个盒子里，盒子不能为空，然后再在每个盒子里拿走 1 个小球，总共拿走了 m 个小球，得到的结果，就是把 n 个小球放到 m 个盒子里，盒子可以为空的解。

把 n + m 个小球放到 m 个盒子里，盒子不能为空的分法，带入上面的公式，就是 C(n + m - 1, m - 1)

所以，把 n 个小球放到 m 个盒子里，盒子可以为空，答案为 C(n + m - 1, m - 1)。



总结：

将 n 个小球放到 m 个盒子里，盒子不为空：C(n - 1, m - 1)；

将 n 个小球放到 m 个盒子里，盒子可以空：C(n + m - 1, m - 1)；

对于这个问题，m = 5，盒子可以为空，所以答案是 C(n + 5 - 1, 5 - 1) = C(n + 4, 4)

```python
class Solution:
    def countVowelStrings(self, n: int) -> int:
        return (n + 4) * (n + 3) * (n + 2) * (n + 1) // 24
```



